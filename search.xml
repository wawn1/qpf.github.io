<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>凑数</title>
    <url>/posts/9b49a010.html</url>
    <content><![CDATA[<h2 id="凑数"><a href="#凑数" class="headerlink" title="凑数"></a>凑数</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入int型数组，询问该数组能否分成两组，使得两组中各元素加起来的和相等，并且，所有5的倍数必须在其中一个组中，所有3的倍数在另一个组中（不包括5的倍数），不是5的倍数也不是3的倍数能放在任意一组，可以将数组分为空数组，能满足以上条件，输出true；不满足时输出false。</p>
<p>数据范围：每个数组大小满足 1≤𝑛≤50，输入的数据大小满足∣val∣≤500 </p>
<h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>第一行是数据个数，第二行是输入的数据</p>
<h3 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h3><p>返回true或者false</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：<br>4<br>1 5 -5 1</p>
<p>输出：<br>true</p>
<p>说明：<br>第一组：5 -5 1<br>第二组：1   </p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rl = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;readline&quot;</span>).<span class="hljs-title function_">createInterface</span>(&#123; <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span> &#125;);<br><span class="hljs-keyword">var</span> iter = rl[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readline</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">await</span> iter.<span class="hljs-title function_">next</span>()).<span class="hljs-property">value</span>;<br><br><span class="hljs-keyword">void</span> (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// Write your code here</span><br>    <span class="hljs-keyword">let</span> lines = [];<br>    <span class="hljs-keyword">while</span> ((line = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readline</span>())) &#123;<br>        lines.<span class="hljs-title function_">push</span>(line);<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> arr = lines[<span class="hljs-number">1</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>);<br><br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>,<br>        sum3 = <span class="hljs-number">0</span>,<br>        sum5 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> rest = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> arr) &#123;<br>        <span class="hljs-keyword">if</span> (num % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>) &#123;<br>            sum3 += num;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>) &#123;<br>            sum5 += num;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rest.<span class="hljs-title function_">push</span>(num);<br>        &#125;<br>        sum += num;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> part = sum / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">let</span> target = part - sum3;<br>    <span class="hljs-comment">// 题目：给出一个list，一个target，任取数，组成target</span><br>    <span class="hljs-comment">// 动态规划，但是有负数，1.数据范围从min~max, 2.数组用map</span><br>    <span class="hljs-keyword">let</span> min = <span class="hljs-number">0</span>,<br>        max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> rest) &#123;<br>        <span class="hljs-keyword">if</span> (v &lt; <span class="hljs-number">0</span>) &#123;<br>            min += v;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            max += v;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 数字可能是负数，不能用数组要用map</span><br>    <span class="hljs-comment">// dp[i][j] 表示给看前i个数，是否能组成j， 01背包</span><br>    <span class="hljs-comment">// dp[i][j] = dp[i-1][j-rest[i]] || dp[i-1][j]</span><br>    <span class="hljs-comment">// dp[0][0] = true</span><br>    <span class="hljs-keyword">let</span> dp = &#123;&#125;;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= rest.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = min; j &lt;= max; j++) &#123;<br>            dp[j] = (dp[j - rest[i - <span class="hljs-number">1</span>]] || <span class="hljs-literal">false</span>) || (dp[j] || <span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dp[target] || <span class="hljs-literal">false</span>);<br>&#125;)();<br><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/posts/86aeeda8.html</url>
    <content><![CDATA[<h2 id="【译】装饰器模式decorator-pattern"><a href="#【译】装饰器模式decorator-pattern" class="headerlink" title="【译】装饰器模式decorator pattern"></a>【译】装饰器模式<a href="https://medium.com/qualyteam-engineering/decorator-design-pattern-in-functional-and-object-oriented-programming-e0a2be3c5679">decorator pattern</a></h2><p>敏捷软件开发依赖于快速变化的能力。新的用户需求和对现有实现的增强将会发生。因此，你的代码将会改变。</p>
<p>但是，S.O.L.I.D的开闭原则又如何呢？</p>
<blockquote>
<p>软件实体（类、模块、函数等）应该对扩展开放，但对修改关闭。</p>
</blockquote>
<p>开闭原则强调一旦一个实体完成，就应该是完成的。你应该为它们提供一种被增强&#x2F;扩展的方式。</p>
<p>在面向对象编程中，可以通过设计模式（如策略模式、模板方法模式）、继承或良好的建模来实现这一点。</p>
<p>而在函数式编程中，你可以通过组合、部分应用、柯里化、高阶函数等概念来实现这一点。</p>
<p>今天我们正在使用一种被两种范式支持的模式，称为装饰器。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>装饰器是一种包装函数，用于增强被包装函数的功能。你不会改变原始函数的行为，而是用新的行为来装饰它，从而实现可扩展性和组合性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">decorator</span> = fn =&gt; <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">//do some enhancement</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">anotherDecorator</span> = fn =&gt; <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">//do another enhancement</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();<br>&#125;<br><br><span class="hljs-comment">//compose decorated functions</span><br><span class="hljs-keyword">const</span> f1 = <span class="hljs-title function_">anotherDecorator</span>(fn);<br><span class="hljs-comment">// f1();</span><br><span class="hljs-keyword">const</span> f2 = <span class="hljs-title function_">anotherDecorator</span>(<span class="hljs-title function_">decorator</span>(fn));<br><span class="hljs-comment">//f2();</span><br></code></pre></td></tr></table></figure>

<h3 id="函数式装饰器"><a href="#函数式装饰器" class="headerlink" title="函数式装饰器"></a>函数式装饰器</h3><p>想象一下，你正在开发一个通过交互界面运行shell命令的JavaScript应用程序。用户通过按下按钮来运行命令，并通过面板查看输出。</p>
<p>你创建了一个函数来抽象有时复杂的spawn&#x2F;exec Node API。这些抽象被称为外观（facades）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">runCommand</span> = (<span class="hljs-params">command, options</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> cmd = <span class="hljs-title function_">spawn</span>(command, &#123;<br>      <span class="hljs-attr">shell</span>: <span class="hljs-literal">true</span>,<br>      ...options<br>    &#125;);<br><br>    cmd.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> print.<span class="hljs-title function_">info</span>(data.<span class="hljs-title function_">toString</span>()));<br>    cmd.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(command));<br>    <br>    cmd.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> print.<span class="hljs-title function_">info</span>(data.<span class="hljs-title function_">toString</span>()));    <br><br>    cmd.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        print.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Command could not be run: <span class="hljs-subst">$&#123;error&#125;</span>`</span>)<br>        <span class="hljs-title function_">reject</span>(error)<br>    &#125;);<br>  &#125;)<br></code></pre></td></tr></table></figure>

<p>这是一个为复杂的NodeJS spawn API进行了封装的Promise化外观。它接受两个参数，一个要运行的shell命令字符串，以及一些传递给spawn原生函数的选项。它运行命令，将输出打印到stdout，并解析或拒绝Promise。</p>
<h3 id="首个功能需求：打印正在运行的命令"><a href="#首个功能需求：打印正在运行的命令" class="headerlink" title="首个功能需求：打印正在运行的命令"></a>首个功能需求：打印正在运行的命令</h3><p>用户们喜欢这个产品，但他们希望能够看到他们发出的命令，而不仅仅是它的输出。</p>
<p>你可以在第一行中添加一个新的print.info(command)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">runCommand</span> = (<span class="hljs-params">command, options</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; shouldPrint, ...rest &#125; = options;<br>    <br>    <span class="hljs-comment">//prints</span><br>    <span class="hljs-keyword">if</span>(shouldPrint) <br>        print.<span class="hljs-title function_">info</span>(command);<br>    <br>    <span class="hljs-comment">//and runs</span><br>    <span class="hljs-keyword">const</span> cmd = <span class="hljs-title function_">spawn</span>(command, &#123;<br>      <span class="hljs-attr">shell</span>: <span class="hljs-literal">true</span>,<br>      ...rest<br>    &#125;);<br><br>    cmd.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> print.<span class="hljs-title function_">info</span>(data.<span class="hljs-title function_">toString</span>()));<br>    cmd.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(command))<br>    <br>    cmd.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> print.<span class="hljs-title function_">info</span>(data.<span class="hljs-title function_">toString</span>()));    <br><br>    cmd.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        print.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Command could not be run: <span class="hljs-subst">$&#123;error&#125;</span>`</span>)<br>        <span class="hljs-title function_">reject</span>(error)<br>    &#125;);<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>但是现在函数名字不再表达它的功能。它既运行命令又打印命令。</p>
<h3 id="第二个功能需求：记忆最后一条命令"><a href="#第二个功能需求：记忆最后一条命令" class="headerlink" title="第二个功能需求：记忆最后一条命令"></a>第二个功能需求：记忆最后一条命令</h3><p>用户希望有一个选项来运行最后一条命令。</p>
<p>我们创建一个名为memoize(command)的函数，使用持久化机制存储最后一条运行的命令。</p>
<p>我们可以在每次命令调用之前调用memoize，但这样会给需要被记忆的命令添加时间耦合，所以让我们将这个行为添加到runCommand中。</p>
<p>这是最终结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">runCommand</span> = (<span class="hljs-params">command, options</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; shouldPrint, shouldMemoize, ...rest &#125; = options;<br>    <br>    <span class="hljs-comment">//prints</span><br>    <span class="hljs-keyword">if</span>(shouldPrint) <br>        print.<span class="hljs-title function_">info</span>(command);<br>        <br>    <span class="hljs-keyword">if</span>(shouldMemoize)<br>        <span class="hljs-title function_">memoize</span>(command);<br>    <br>    <span class="hljs-comment">//and runs</span><br>    <span class="hljs-keyword">const</span> cmd = <span class="hljs-title function_">spawn</span>(command, &#123;<br>      <span class="hljs-attr">shell</span>: <span class="hljs-literal">true</span>,<br>      ...rest<br>    &#125;);<br><br>    cmd.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> print.<span class="hljs-title function_">info</span>(data.<span class="hljs-title function_">toString</span>()));<br>    cmd.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(command))<br>    <br>    cmd.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> print.<span class="hljs-title function_">info</span>(data.<span class="hljs-title function_">toString</span>()));    <br><br>    cmd.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        print.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Command could not be run: <span class="hljs-subst">$&#123;error&#125;</span>`</span>)<br>        <span class="hljs-title function_">reject</span>(error)<br>    &#125;);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>这个函数做了太多的事情，而且越来越庞大。我们将使用装饰器模式，这样我们就可以在不修改原始函数的情况下组合这些行为。</p>
<h3 id="遇见装饰器模式"><a href="#遇见装饰器模式" class="headerlink" title="遇见装饰器模式"></a>遇见装饰器模式</h3><p>装饰器是增强被包装函数的包装函数。有一个TC39提案将其转化为ECMA Script规范。如果该提案成为标准，我们将支持装饰器作为ECMA Script的一级语言构造。但由于目前它只处于第2阶段，即草案阶段，我们将使用高阶函数创建自己的装饰器。</p>
<p>首先，让我们将我们的runCommand函数改回原始版本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">runCommand</span> = (<span class="hljs-params">command, options</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> cmd = <span class="hljs-title function_">spawn</span>(command, &#123;<br>      <span class="hljs-attr">shell</span>: <span class="hljs-literal">true</span>,<br>      ...options<br>    &#125;);<br><br>    cmd.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> print.<span class="hljs-title function_">info</span>(data.<span class="hljs-title function_">toString</span>()));<br>    cmd.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(command));<br>    <br>    cmd.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> print.<span class="hljs-title function_">info</span>(data.<span class="hljs-title function_">toString</span>()));    <br><br>    cmd.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        print.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Command could not be run: <span class="hljs-subst">$&#123;error&#125;</span>`</span>)<br>        <span class="hljs-title function_">reject</span>(error)<br>    &#125;);<br>  &#125;)<br></code></pre></td></tr></table></figure>

<p>让我们用打印行为来装饰这个函数。首先，我们创建一个高阶函数，它接收一个函数并打印第一个参数。然后，我们返回装饰后的函数本身：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">withCommandLogger</span> = func =&gt; <span class="hljs-function">(<span class="hljs-params">command, options</span>) =&gt;</span> &#123;<br>    print.<span class="hljs-title function_">info</span>(<span class="hljs-string">`Running command: <span class="hljs-subst">$&#123;command&#125;</span>`</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(command, options)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withCommandLogger</span>(runCommand);<br></code></pre></td></tr></table></figure>

<p>withCommandLogger装饰器返回一个装饰后的函数。我们可以无缝地使用它，就好像我们不知道它已经被装饰了一样。请注意，我们没有修改原始的runCommand函数，这很好，如果你想在不打印正在运行的命令的情况下使用它。</p>
<p>现在，让我们再次装饰命令，添加memoize功能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">withMemoize</span> = func =&gt; <span class="hljs-function">(<span class="hljs-params">command, options</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">memoize</span>(command);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(comand, options);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withMemoize</span>(<span class="hljs-title function_">withLogger</span>(runCommand));<br></code></pre></td></tr></table></figure>

<h3 id="第三个功能需求：测量命令执行时间"><a href="#第三个功能需求：测量命令执行时间" class="headerlink" title="第三个功能需求：测量命令执行时间"></a>第三个功能需求：测量命令执行时间</h3><p>现在我们知道了装饰器模式，很容易在不修改原始函数的情况下增强它。让我们来实现第三个功能请求：测量命令执行时间。我们可以创建一个名为withTimeTracker的装饰器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">withTimeTracker</span> = func =&gt; <span class="hljs-function">(<span class="hljs-params">command, options</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> start = process.<span class="hljs-title function_">hrtime</span>();<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">func</span>(command, options);<br>    <span class="hljs-keyword">const</span> [ seconds, nanoseconds ] = process.<span class="hljs-title function_">hrtime</span>(start);<br>    print.<span class="hljs-title function_">info</span>(<span class="hljs-string">`Time ellapsed <span class="hljs-subst">$&#123;seconds&#125;</span>s <span class="hljs-subst">$&#123;(nanoseconds/<span class="hljs-number">1000000</span>)&#125;</span>ms`</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们使用process.hrtime Node API来记录高分辨率的经过时间，避免了一些Date API的精度问题。请注意，这个装饰器实际上会执行被装饰的函数，所以它应该是最后一个被调用的。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>装饰器是一种设计模式，可以在不修改原始函数的情况下实现高度的可扩展性。它通过组合的方式，为我们提供了一种动态增强函数的方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> run = <span class="hljs-title function_">withTimeTracker</span>(<span class="hljs-title function_">withMemoize</span>(<span class="hljs-title function_">withCommandLogger</span>(runCommand)));<br><br><span class="hljs-title function_">run</span>(<span class="hljs-string">&#x27;ls&#x27;</span>, &#123; <span class="hljs-attr">cwd</span>: <span class="hljs-string">&#x27;/home/user&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure>

<h3 id="剩余参数-更通用的装饰器"><a href="#剩余参数-更通用的装饰器" class="headerlink" title="剩余参数, 更通用的装饰器"></a>剩余参数, 更通用的装饰器</h3><p>你可能已经注意到我们的装饰器与原始的runCommand函数签名耦合在一起，它期望两个参数。我们可以通过使用剩余参数来使我们的装饰器增强任何函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">withCache</span> = func =&gt; <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">getOrWriteToCache</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">func</span>(...args));<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">withEventSourcing</span> = func =&gt; <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>    eventStore.<span class="hljs-title function_">publish</span>(func, &#123; ...args &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(...args);<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">withLoggly</span> = func =&gt; <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>    logglyClient.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;func.name&#125;</span> called with args <span class="hljs-subst">$&#123;args.reduce((acc, curr) =&gt; acc + <span class="hljs-string">&#x27;,&#x27;</span> + curr) &#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(...args);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过使用剩余参数语法…，装饰器不需要知道被装饰函数的参数。它们只是接收任意数量的参数，并将它们传递给被装饰的函数。</p>
]]></content>
      <categories>
        <category>Patterns</category>
      </categories>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/posts/90c5a5f7.html</url>
    <content><![CDATA[<h2 id="【译】享元模式Flyweight-Pattern"><a href="#【译】享元模式Flyweight-Pattern" class="headerlink" title="【译】享元模式Flyweight Pattern "></a>【译】享元模式<a href="https://www.patterns.dev/vanilla/flyweight-pattern">Flyweight Pattern </a></h2><p>享元模式是在创建大量相似对象时节省内存的一种有用方式。</p>
<p>在我们的应用程序中，我们希望用户能够添加图书。所有图书都有一个标题、一个作者和一个ISBN号！然而，图书馆通常不只有一本书的副本：通常会有多本相同的书。</p>
<p>如果有多本完全相同的书，每次都创建一个新的书实例就没有太大意义了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">title, author, isbn</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">author</span> = author;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isbn</span> = isbn;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>让我们创建将新书添加到列表的功能。如果一本书具有相同的ISBN号，即完全相同的书籍类型，我们不希望创建一个全新的Book实例。相反，我们应该首先检查这本书是否已经存在。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">createBook</span> = (<span class="hljs-params">title, author, isbn</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> existingBook = books.<span class="hljs-title function_">has</span>(isbn);<br><br>  <span class="hljs-keyword">if</span> (existingBook) &#123;<br>    <span class="hljs-keyword">return</span> books.<span class="hljs-title function_">get</span>(isbn);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>如果它还不包含该书的ISBN号，我们将创建一本新书，并将其ISBN号添加到isbnNumbers集合中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createBook</span> = (<span class="hljs-params">title, author, isbn</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> existingBook = books.<span class="hljs-title function_">has</span>(isbn);<br><br>  <span class="hljs-keyword">if</span> (existingBook) &#123;<br>    <span class="hljs-keyword">return</span> books.<span class="hljs-title function_">get</span>(isbn);<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(title, author, isbn);<br>  books.<span class="hljs-title function_">set</span>(isbn, book);<br><br>  <span class="hljs-keyword">return</span> book;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>createBook函数帮助我们创建同一类型的新书实例。然而，图书馆通常包含多本相同的书！让我们创建一个addProduct函数，它允许我们添加多本相同的书。它应该调用createBook函数，该函数返回一个新创建的Book实例，或者返回已经存在的实例。</p>
<p>为了跟踪总的副本数量，让我们创建一个productList数组，其中包含图书馆中的总书量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> productList = [];<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">addProduct</span> = (<span class="hljs-params">title, author, isbn, availibility, sales</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> product = &#123;<br>    <span class="hljs-attr">book</span>: <span class="hljs-title function_">createBook</span>(title, author, isbn),<br>    sales,<br>    availibility,<br>    isbn<br>  &#125;;<br><br>  productList.<span class="hljs-title function_">push</span>(product);<br><br>  <span class="hljs-keyword">return</span> product;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>太棒了！在每次添加副本时，我们可以有效地使用已经存在的Book实例来表示该特定副本。让我们创建3本书的5个副本：《哈利·波特》、《杀死一只知更鸟》和《了不起的盖茨比》。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">addProduct</span>(<span class="hljs-string">&quot;Harry Potter&quot;</span>, <span class="hljs-string">&quot;JK Rowling&quot;</span>, <span class="hljs-string">&quot;AB123&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">100</span>);<br><span class="hljs-title function_">addProduct</span>(<span class="hljs-string">&quot;Harry Potter&quot;</span>, <span class="hljs-string">&quot;JK Rowling&quot;</span>, <span class="hljs-string">&quot;AB123&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">50</span>);<br><span class="hljs-title function_">addProduct</span>(<span class="hljs-string">&quot;To Kill a Mockingbird&quot;</span>, <span class="hljs-string">&quot;Harper Lee&quot;</span>, <span class="hljs-string">&quot;CD345&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">10</span>);<br><span class="hljs-title function_">addProduct</span>(<span class="hljs-string">&quot;To Kill a Mockingbird&quot;</span>, <span class="hljs-string">&quot;Harper Lee&quot;</span>, <span class="hljs-string">&quot;CD345&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">20</span>);<br><span class="hljs-title function_">addProduct</span>(<span class="hljs-string">&quot;The Great Gatsby&quot;</span>, <span class="hljs-string">&quot;F. Scott Fitzgerald&quot;</span>, <span class="hljs-string">&quot;EF567&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">20</span>);<br><br></code></pre></td></tr></table></figure>
<p>尽管有5个副本，但我们只有3个Book实例！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">title, author, isbn</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">author</span> = author;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isbn</span> = isbn;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> isbnNumbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">const</span> productList = [];<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">createBook</span> = (<span class="hljs-params">title, author, isbn</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> book = isbnNumbers.<span class="hljs-title function_">has</span>(isbn);<br>  <span class="hljs-keyword">if</span> (book) &#123;<br>    <span class="hljs-keyword">return</span> book;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(title, author, isbn);<br>    isbnNumbers.<span class="hljs-title function_">add</span>(isbn);<br>    <span class="hljs-keyword">return</span> book;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">addProduct</span> = (<span class="hljs-params">title, author, isbn, availibility, sales</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> product = &#123;<br>    <span class="hljs-attr">book</span>: <span class="hljs-title function_">createBook</span>(title, author, isbn),<br>    sales,<br>    availibility,<br>    isbn<br>  &#125;;<br><br>  productList.<span class="hljs-title function_">push</span>(product);<br><br>  <span class="hljs-keyword">return</span> product;<br>&#125;;<br><br><span class="hljs-title function_">addProduct</span>(<span class="hljs-string">&quot;Harry Potter&quot;</span>, <span class="hljs-string">&quot;JK Rowling&quot;</span>, <span class="hljs-string">&quot;AB123&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">100</span>);<br><span class="hljs-title function_">addProduct</span>(<span class="hljs-string">&quot;Harry Potter&quot;</span>, <span class="hljs-string">&quot;JK Rowling&quot;</span>, <span class="hljs-string">&quot;AB123&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">50</span>);<br><span class="hljs-title function_">addProduct</span>(<span class="hljs-string">&quot;To Kill a Mockingbird&quot;</span>, <span class="hljs-string">&quot;Harper Lee&quot;</span>, <span class="hljs-string">&quot;CD345&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">10</span>);<br><span class="hljs-title function_">addProduct</span>(<span class="hljs-string">&quot;To Kill a Mockingbird&quot;</span>, <span class="hljs-string">&quot;Harper Lee&quot;</span>, <span class="hljs-string">&quot;CD345&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">20</span>);<br><span class="hljs-title function_">addProduct</span>(<span class="hljs-string">&quot;The Great Gatsby&quot;</span>, <span class="hljs-string">&quot;F. Scott Fitzgerald&quot;</span>, <span class="hljs-string">&quot;EF567&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">20</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Total amount of copies: &quot;</span>, productList.<span class="hljs-property">length</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Total amount of books: &quot;</span>, isbnNumbers.<span class="hljs-property">size</span>);<br></code></pre></td></tr></table></figure>

<p>当您创建大量对象时，使用享元模式非常有用，因为这可能会耗尽所有可用的内存。它允许我们最小化内存的消耗。</p>
<p>在JavaScript中，我们可以通过原型继承轻松解决这个问题。如今，硬件拥有GB级的内存，这使得享元模式变得不那么重要。</p>
]]></content>
      <categories>
        <category>Patterns</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode10</title>
    <url>/posts/3157d16d.html</url>
    <content><![CDATA[<h3 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a href="https://leetcode.cn/problems/regular-expression-matching/">10. 正则表达式匹配</a></h3><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<p>示例 1：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-attr">p</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：<span class="hljs-string">&quot;a&quot;</span> 无法匹配 <span class="hljs-string">&quot;aa&quot;</span> 整个字符串。<br></code></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;aa&quot;</span>, p = <span class="hljs-string">&quot;a*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：因为 <span class="hljs-string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="hljs-string">&#x27;a&#x27;</span>。因此，字符串 <span class="hljs-string">&quot;aa&quot;</span> 可被视为 <span class="hljs-string">&#x27;a&#x27;</span> 重复了一次。<br></code></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;ab&quot;</span>, p = <span class="hljs-string">&quot;.*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="hljs-string">&#x27;*&#x27;</span>）任意字符（<span class="hljs-string">&#x27;.&#x27;</span>）。<br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/regular-expression-matching">https://leetcode.cn/problems/regular-expression-matching</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">dp[i][j] 表示给字符串前i个字符，给看正则串的前j个字符，能否匹配<br><br>i j字符匹配，分类讨论<br>如果i j匹配, s[i]===p[j]或p[j]===<span class="hljs-string">&#x27;.&#x27;</span>,  dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>如果i j不匹配, <br>    如果p[j]是*<br>       如果i j<span class="hljs-number">-1</span>匹配  <br>       	  如果匹配<span class="hljs-number">0</span>次, dp[i][j<span class="hljs-number">-2</span>]<br>       	  如果匹配多次，dp[i<span class="hljs-number">-1</span>][j]<br>       如果i j<span class="hljs-number">-1</span>不匹配，dp[i][j<span class="hljs-number">-2</span>]<br>    如果p[j]是正常字符，false <br>    <br>初始化<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=true<br>dp[i][<span class="hljs-number">0</span>]=false<br>dp[<span class="hljs-number">0</span>][j] 不一定  s: <span class="hljs-string">&#x27;&#x27;</span>, p: <span class="hljs-string">&#x27;a*&#x27;</span><br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isEqual</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>, p: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">if</span> (!s || !p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">return</span> s === p || p === <span class="hljs-string">&quot;.&quot;</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span>, p: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">let</span> n = s.<span class="hljs-property">length</span>,<br>    m = p.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> dp = <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>)<br>    .<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>(m + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>));<br><br>  dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isEqual</span>(s[i - <span class="hljs-number">1</span>], p[j - <span class="hljs-number">1</span>])) &#123;<br>        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] === <span class="hljs-string">&quot;*&quot;</span>) &#123;<br>        dp[i][j] = dp[i][j - <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isEqual</span>(s[i - <span class="hljs-number">1</span>], p[j - <span class="hljs-number">2</span>])) &#123;<br>          dp[i][j] = dp[i][j] || dp[i - <span class="hljs-number">1</span>][j];<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode141</title>
    <url>/posts/d4826087.html</url>
    <content><![CDATA[<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h3><p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<p>示例 1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1], pos = -1<br>输出：<span class="hljs-literal">false</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/linked-list-cycle">https://leetcode.cn/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">快慢指针，1个速度为1,1个速度为2，只要在环上，快指针以相对速度1追赶慢指针，一定能追上<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">head: ListNode | <span class="hljs-literal">null</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">if</span> (!head || !head.<span class="hljs-property">next</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">let</span> fast = head,<br>    slow = head;<br>  <span class="hljs-keyword">while</span> (fast !== <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) &#123;<br>    slow = slow.<span class="hljs-property">next</span>;<br>    fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">if</span> (slow === fast) <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (fast != slow) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode142</title>
    <url>/posts/4d8b313d.html</url>
    <content><![CDATA[<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h3><p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<p>示例 1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">pos</span> = -<span class="hljs-number">1</span><br>输出：返回 <span class="hljs-literal">null</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/linked-list-cycle-ii">https://leetcode.cn/problems/linked-list-cycle-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><img src="/pic/loop.png" width="600">

<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-number">4</span>个点，<br><span class="hljs-selector-tag">a</span>: <span class="hljs-number">0</span>点（<span class="hljs-number">0</span>位置起点）<br><span class="hljs-selector-tag">b</span>: 环起点<br><span class="hljs-selector-tag">c</span>: 慢指针在环起点时，快指针的位置<br><span class="hljs-selector-tag">d</span>: 相遇点<br><br><span class="hljs-selector-tag">c</span>位置的特殊性, 从<span class="hljs-selector-tag">b</span>点先走了<span class="hljs-selector-tag">x</span>，再走<span class="hljs-selector-tag">y</span>就回到<span class="hljs-selector-tag">b</span>点<br>所以，从<span class="hljs-selector-tag">b</span>点走<span class="hljs-selector-tag">x</span>+<span class="hljs-selector-tag">y</span>可以回到<span class="hljs-selector-tag">b</span>点<br>快指针以相对速度<span class="hljs-number">1</span>追赶慢指针，经过<span class="hljs-selector-tag">y</span>追上，<span class="hljs-number">2</span>个指针都从<span class="hljs-selector-tag">b</span>点走了<span class="hljs-selector-tag">y</span>，只要再走<span class="hljs-selector-tag">x</span>就回到<span class="hljs-selector-tag">b</span><br><br></code></pre></td></tr></table></figure>


<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">detectCycle</span>(<span class="hljs-params">head: ListNode | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">ListNode</span> | <span class="hljs-literal">null</span> &#123;<br>  <span class="hljs-keyword">if</span> (!head || !head.<span class="hljs-property">next</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">let</span> fast = head,<br>    slow = head;<br>  <span class="hljs-keyword">while</span> (fast !== <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) &#123;<br>    slow = slow.<span class="hljs-property">next</span>;<br>    fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">if</span> (slow === fast) <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (fast !== slow) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>  fast = head;<br>  <span class="hljs-keyword">while</span> (fast !== slow) &#123;<br>    fast = fast.<span class="hljs-property">next</span>;<br>    slow = slow.<span class="hljs-property">next</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> fast;<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode148</title>
    <url>/posts/ad5ed823.html</url>
    <content><![CDATA[<h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/description/">148. 排序链表</a></h3><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<p>示例 1：</p>
<p>输入：head &#x3D; [4,2,1,3]<br>输出：[1,2,3,4]<br>示例 2：</p>
<p>输入：head &#x3D; [-1,5,3,4,0]<br>输出：[-1,0,3,4,5]<br>示例 3：</p>
<p>输入：head &#x3D; []<br>输出：[]</p>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 5 * 104] 内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</p>
<p>进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>2个排序的链表归并排序：时间复杂度O(n+m), 空间复杂度O(1)</p>
<p>单个元素已经是有序的，那么往前2个元素就是2个有序链表可以归并<br>归并一趟后，2个元素为长度的为有序，下次可以归并的链表长度是2*i<br>[4] [3] [2] [1] [5]<br>[3, 4] [1, 2] [5]<br>[1, 2, 3, 4] [5]<br>[1, 2, 3, 4, 5]</p>
<p>每次的时间复杂度：O(n)</p>
<p>次数：logn</p>
<p>总时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> sortList = <span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) &#123;<br><br>    <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> p = head<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        total++<br>        p = p.<span class="hljs-property">next</span><br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSortedList</span>(<span class="hljs-params">head1, head2</span>) &#123;<br>        <span class="hljs-keyword">let</span> dummyHead = &#123; <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> &#125;<br>        <span class="hljs-keyword">let</span> p = dummyHead<br>        <span class="hljs-keyword">let</span> i = head1, j = head2<br>        <span class="hljs-keyword">while</span> (i !== <span class="hljs-literal">null</span> &amp;&amp; j !== <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (i.<span class="hljs-property">val</span> &lt;= j.<span class="hljs-property">val</span>) &#123;<br>                p.<span class="hljs-property">next</span> = i<br>                p = p.<span class="hljs-property">next</span><br>                i = i.<span class="hljs-property">next</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                p.<span class="hljs-property">next</span> = j<br>                p = p.<span class="hljs-property">next</span><br>                j = j.<span class="hljs-property">next</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i !== <span class="hljs-literal">null</span>) &#123;<br>            p.<span class="hljs-property">next</span> = i<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j !== <span class="hljs-literal">null</span>) &#123;<br>            p.<span class="hljs-property">next</span> = j<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummyHead.<span class="hljs-property">next</span><br>    &#125;<br><br>    <span class="hljs-keyword">let</span> dummyHead = &#123; <span class="hljs-attr">next</span>: head &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> len = <span class="hljs-number">1</span>; len &lt; total; len *= <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// O(logn)</span><br>        <span class="hljs-keyword">let</span> restHead = dummyHead.<span class="hljs-property">next</span> <span class="hljs-comment">// 剩余的部分开头节点</span><br>        <span class="hljs-keyword">let</span> p = dummyHead <span class="hljs-comment">// 已归并的链表尾部</span><br>        <span class="hljs-keyword">while</span> (restHead) &#123;<br>            <span class="hljs-keyword">let</span> lhead = restHead<br>            <span class="hljs-keyword">let</span> ltail = lhead<br><br>            <span class="hljs-comment">// 找到左链表头，尾，将尾部断开，更新未处理的开头节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len &amp;&amp; ltail !== <span class="hljs-literal">null</span>; i++) &#123;<br>                ltail = ltail.<span class="hljs-property">next</span><br>            &#125;<br><br>            <span class="hljs-keyword">let</span> rhead = ltail ? ltail.<span class="hljs-property">next</span> : <span class="hljs-literal">null</span><br>            <span class="hljs-keyword">if</span> (ltail &amp;&amp; ltail.<span class="hljs-property">next</span>) ltail.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span><br><br>            <span class="hljs-comment">// 找到右链表头，尾，将尾部断开，更新未处理的开头节点</span><br>            <span class="hljs-keyword">let</span> rtail = rhead<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len &amp;&amp; rtail !== <span class="hljs-literal">null</span>; i++) &#123;<br>                rtail = rtail.<span class="hljs-property">next</span><br>            &#125;<br><br>            restHead = rtail ? rtail.<span class="hljs-property">next</span> : <span class="hljs-literal">null</span><br>            <span class="hljs-keyword">if</span> (rtail &amp;&amp; rtail.<span class="hljs-property">next</span>) rtail.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span><br><br>            <span class="hljs-comment">// 合并左右链表，将合并后链表结点，把尾部接上</span><br>            p.<span class="hljs-property">next</span> = <span class="hljs-title function_">mergeSortedList</span>(lhead, rhead) <span class="hljs-comment">// O(n)</span><br><br>            <span class="hljs-keyword">while</span> (p.<span class="hljs-property">next</span>) &#123;<br>                p = p.<span class="hljs-property">next</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> p1 = dummyHead.<span class="hljs-property">next</span><br>    <span class="hljs-keyword">while</span> (p1) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">val</span>)<br>        p1 = p1.<span class="hljs-property">next</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummyHead.<span class="hljs-property">next</span><br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode153</title>
    <url>/posts/239730ea.html</url>
    <content><![CDATA[<h3 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h3><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,2,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<p>示例 1：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br>解释：原数组为 <span class="hljs-string">[1,2,3,4,5]</span> ，旋转 <span class="hljs-number">3</span> 次得到输入数组。<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span><br>输出：<span class="hljs-number">0</span><br>解释：原数组为 <span class="hljs-string">[0,1,2,4,5,6,7]</span> ，旋转 <span class="hljs-number">4</span> 次得到输入数组。<br></code></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[11,13,15,17]</span><br>输出：<span class="hljs-number">11</span><br>解释：原数组为 <span class="hljs-string">[11,13,15,17]</span> ，旋转 <span class="hljs-number">4</span> 次得到输入数组。<br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">如果nums[<span class="hljs-built_in">mid</span>]&gt;nums[r]，<span class="hljs-built_in">mid</span>和<span class="hljs-built_in">mid</span>左侧都可以去掉<br>如果nums[<span class="hljs-built_in">mid</span>]&lt;=nums[r]，<span class="hljs-built_in">mid</span>可能是解，<span class="hljs-built_in">mid</span>的右侧可以去掉<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMin</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">let</span> n = nums.<span class="hljs-property">length</span><br><br>    <span class="hljs-keyword">let</span> l=<span class="hljs-number">0</span>, r=n-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-keyword">let</span> mid= (l+r)&gt;&gt;&gt;<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[r]) &#123;<br>            l=mid+<span class="hljs-number">1</span><br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            r=mid<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[l]<br>&#125;;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode154</title>
    <url>/posts/bdf3a549.html</url>
    <content><![CDATA[<h3 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a></h3><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,4,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]<br>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p>
<p>你必须尽可能减少整个过程的操作步骤。</p>
<p>示例 1：</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,3,5]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><img src="/pic/lc154.png" width="600">
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">如果nums[<span class="hljs-built_in">mid</span>]&gt;nums[r]，<span class="hljs-built_in">mid</span>和<span class="hljs-built_in">mid</span>左侧都可以去掉<br>如果nums[<span class="hljs-built_in">mid</span>]&lt;nums[r]，<span class="hljs-built_in">mid</span>可能是解，<span class="hljs-built_in">mid</span>右侧都可以去掉<br>如果nums[<span class="hljs-built_in">mid</span>]=nums[r]，<span class="hljs-built_in">mid</span>可能是解<br>    <span class="hljs-built_in">mid</span>可能在后半部的水平线，可能在前半部的水平线，不能直接去掉右侧<br>    但是必须至少收缩<span class="hljs-number">1</span>个，不然死循环<br>    r可以去掉，不漏解<br>    <br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMin</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> n = nums.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>,<br>    r = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-keyword">let</span> mid = (l + r) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[r]) &#123;<br>      r = mid;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[r]) &#123;<br>      l = mid + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      r = r - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> nums[l];<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode165</title>
    <url>/posts/e1d9c61c.html</url>
    <content><![CDATA[<h3 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a href="https://leetcode.cn/problems/compare-version-numbers/description/">165. 比较版本号</a></h3><p>给你两个 版本号字符串 version1 和 version2 ，请你比较它们。版本号由被点 ‘.’ 分开的修订号组成。修订号的值 是它 转换为整数 并忽略前导零。</p>
<p>比较版本号时，请按 从左到右的顺序 依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为 0。</p>
<p>返回规则如下：</p>
<p>如果 version1 &lt; version2 返回 -1，<br>如果 version1 &gt; version2 返回 1，<br>除此之外返回 0。</p>
<p>示例 1：<br>输入：version1 &#x3D; “1.2”, version2 &#x3D; “1.10”<br>输出：-1<br>解释：<br>version1 的第二个修订号为 “2”，version2 的第二个修订号为 “10”：2 &lt; 10，所以 version1 &lt; version2。</p>
<p>示例 2：<br>输入：version1 &#x3D; “1.01”, version2 &#x3D; “1.001”<br>输出：0<br>解释：<br>忽略前导零，”01” 和 “001” 都代表相同的整数 “1”。</p>
<p>示例 3：<br>输入：version1 &#x3D; “1.0”, version2 &#x3D; “1.0.0.0”<br>输出：0<br>解释：<br>version1 有更少的修订号，每个缺失的修订号按 “0” 处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">version1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">version2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> compareVersion = <span class="hljs-keyword">function</span> (<span class="hljs-params">version1, version2</span>) &#123;<br>    <span class="hljs-keyword">let</span> arr1 = version1.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>)<br>    <span class="hljs-keyword">let</span> arr2 = version2.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Number</span>)<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; arr1.<span class="hljs-property">length</span> || j &lt; arr2.<span class="hljs-property">length</span>; i++, j++) &#123;<br>        <span class="hljs-keyword">let</span> a = arr1[i] || <span class="hljs-number">0</span><br>        <span class="hljs-keyword">let</span> b = arr2[j] || <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a &lt; b) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/posts/383e610.html</url>
    <content><![CDATA[<h2 id="【译】工厂模式Factory-Pattern"><a href="#【译】工厂模式Factory-Pattern" class="headerlink" title="【译】工厂模式Factory Pattern"></a>【译】工厂模式<a href="https://www.patterns.dev/vanilla/factory-pattern">Factory Pattern</a></h2><p>使用工厂模式，我们可以使用工厂函数来创建新的对象。当一个函数在不使用new关键字的情况下返回一个新的对象时，它就是一个工厂函数！</p>
<p>假设我们的应用程序需要许多用户。我们可以使用<code>firstName</code>、<code>lastName</code>和<code>email</code>属性创建新用户。工厂函数还会为新创建的对象添加一个<code>fullName</code>属性，该属性返回<code>firstName+lastName</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createUser</span> = (<span class="hljs-params">&#123; firstName, lastName, email &#125;</span>) =&gt; (&#123;<br>  firstName,<br>  lastName,<br>  email,<br>  <span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.firstName&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.lastName&#125;</span>`</span>;<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>太棒了！现在我们可以通过调用createUser函数轻松地创建多个用户了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createUser</span> = (<span class="hljs-params">&#123; firstName, lastName, email &#125;</span>) =&gt; (&#123;<br>  firstName,<br>  lastName,<br>  email,<br>  <span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.firstName&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.lastName&#125;</span>`</span>;<br>  &#125;<br>&#125;);<br><br><br><span class="hljs-keyword">const</span> user1 = <span class="hljs-title function_">createUser</span>(&#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Doe&quot;</span>,<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;john@doe.com&quot;</span><br>&#125;);<br><br><br><span class="hljs-keyword">const</span> user2 = <span class="hljs-title function_">createUser</span>(&#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Jane&quot;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Doe&quot;</span>,<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;jane@doe.com&quot;</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user2);<br></code></pre></td></tr></table></figure>

<p>如果我们正在创建相对复杂和可配置的对象，工厂模式会非常有用。在键和值取决于特定环境或配置的情况很有用。使用工厂模式，我们可以轻松地创建包含自定义键和值的新对象！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createObjectFromArray</span> = (<span class="hljs-params">[key, value]</span>) =&gt; (&#123;<br>  [key]: value,<br>&#125;);<br><br><span class="hljs-title function_">createObjectFromArray</span>([<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>]); <span class="hljs-comment">// &#123; name: &quot;John&quot; &#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>当我们需要创建非常多相同属性的对象时，工厂模式非常有用。根据当前环境或用户特定配置，工厂函数可以轻松返回自定义对象。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>在JavaScript中，工厂模式不过是一个在不使用new关键字的情况下返回对象的函数。ES6箭头函数允许我们创建小型工厂函数，每次都会隐式返回一个对象。</p>
<p>然而，在许多情况下，每次创建class对象更节省内存。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstName, lastName, email</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = lastName;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">email</span> = email;<br>  &#125;<br><br>  <span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.firstName&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.lastName&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> user1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(&#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Doe&quot;</span>,<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;john@doe.com&quot;</span>,<br>&#125;);<br><br><span class="hljs-keyword">const</span> user2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(&#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Jane&quot;</span>,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Doe&quot;</span>,<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;jane@doe.com&quot;</span>,<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user1.<span class="hljs-property">fullName</span> === <span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">fullName</span>) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user2.<span class="hljs-property">fullName</span> === user1.<span class="hljs-property">fullName</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Patterns</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode19</title>
    <url>/posts/488b69c9.html</url>
    <content><![CDATA[<h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>示例 1：<br>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]</p>
<p>示例 2：<br>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]</p>
<p>示例 3：<br>输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">n</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removeNthFromEnd = <span class="hljs-keyword">function</span>(<span class="hljs-params">head, n</span>) &#123;<br>    <span class="hljs-keyword">let</span> dummyHead = &#123;<span class="hljs-attr">next</span>: head&#125; <span class="hljs-comment">// 注意删除就有可能，list=[1],全删掉,要有虚拟头结点</span><br>    <span class="hljs-keyword">let</span> fast = dummyHead<br>    <span class="hljs-keyword">while</span>(n--) &#123;<br>        fast = fast.<span class="hljs-property">next</span><br>    &#125;<br>    <span class="hljs-keyword">let</span> slow = dummyHead<br><br>    <span class="hljs-comment">// 只要下一个有就往下走</span><br>    <span class="hljs-keyword">while</span>(fast?.<span class="hljs-property">next</span>) &#123;<br>        slow = slow.<span class="hljs-property">next</span><br>        fast = fast.<span class="hljs-property">next</span><br>    &#125;<br><br>    slow.<span class="hljs-property">next</span> = slow.<span class="hljs-property">next</span>?.<span class="hljs-property">next</span> ?? <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> dummyHead.<span class="hljs-property">next</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode206</title>
    <url>/posts/2ccc8e79.html</url>
    <content><![CDATA[<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表</a></h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p>示例 1：<br>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p>
<p>示例 2：<br>输入：head &#x3D; [1,2]<br>输出：[2,1]</p>
<p>示例 3：<br>输入：head &#x3D; []<br>输出：[]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reverseList = <span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!head) &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> a = <span class="hljs-literal">null</span> <span class="hljs-comment">// 当前节点前一个节点</span><br>    <span class="hljs-keyword">let</span> b = head <span class="hljs-comment">// 当前节点</span><br><br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">let</span> c = b.<span class="hljs-property">next</span> <span class="hljs-comment">// 缓存下一个节点</span><br><br>        b.<span class="hljs-property">next</span> = a<br>        a = b<br>        b = c<br>    &#125;<br><br>    <span class="hljs-comment">// b走到null了，a是最后一个节点</span><br>    <span class="hljs-keyword">return</span> a<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode213</title>
    <url>/posts/45bd4bb7.html</url>
    <content><![CDATA[<h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 2），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 2）, 因为他们是相邻的。<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 1），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 3）。<br>​     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,2,3]</span><br><span class="hljs-string">输出：3</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/house-robber-ii">https://leetcode.cn/problems/house-robber-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p><img src="/pic/lc213.png"></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">如果第一家偷了，最后一家就没偷，<span class="hljs-built_in">max</span>(<span class="hljs-built_in">T</span>[<span class="hljs-built_in">len</span>-<span class="hljs-number">2</span>], <span class="hljs-built_in">N</span>[<span class="hljs-built_in">len</span>-<span class="hljs-number">2</span>])局部最优解<br>如果第一家没偷，最后一家随便，<span class="hljs-built_in">max</span>(<span class="hljs-built_in">T</span>[<span class="hljs-built_in">len</span>-<span class="hljs-number">1</span>], <span class="hljs-built_in">N</span>[<span class="hljs-built_in">len</span>-<span class="hljs-number">1</span>]) 局部最优解<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">if</span> (nums.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (nums.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...nums);<br><br>  <span class="hljs-keyword">let</span> t = [nums[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>],<br>    nt = [<span class="hljs-number">0</span>, nums[<span class="hljs-number">0</span>]];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>    t.<span class="hljs-title function_">push</span>(nt[i - <span class="hljs-number">1</span>] + nums[i]);<br>    nt.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(nt[i - <span class="hljs-number">1</span>], t[i - <span class="hljs-number">1</span>]));<br>  &#125;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(t.<span class="hljs-title function_">pop</span>(), nt.<span class="hljs-title function_">pop</span>());<br><br>  t = [<span class="hljs-number">0</span>, nums[<span class="hljs-number">1</span>]];<br>  nt = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>    t.<span class="hljs-title function_">push</span>(nt[i - <span class="hljs-number">1</span>] + nums[i]);<br>    nt.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(nt[i - <span class="hljs-number">1</span>], t[i - <span class="hljs-number">1</span>]));<br>  &#125;<br>  res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(t.<span class="hljs-title function_">pop</span>(), nt.<span class="hljs-title function_">pop</span>(), res);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/posts/a2a33980.html</url>
    <content><![CDATA[<h2 id="【译】命令模式command-pattern"><a href="#【译】命令模式command-pattern" class="headerlink" title="【译】命令模式command-pattern"></a>【译】命令模式<a href="https://www.patterns.dev/vanilla/command-pattern">command-pattern</a></h2><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>使用命令模式，我们可以将执行特定任务的对象与调用方法的对象解耦。</p>
<p>比如说，我们有一个在线食品配送平台。用户可以下单、追踪和取消订单。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderManager</span>() &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orders</span> = []<br>  &#125;<br><br>  <span class="hljs-title function_">placeOrder</span>(<span class="hljs-params">order, id</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orders</span>.<span class="hljs-title function_">push</span>(id)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`You have successfully ordered <span class="hljs-subst">$&#123;order&#125;</span> (<span class="hljs-subst">$&#123;id&#125;</span>)`</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">trackOrder</span>(<span class="hljs-params">id</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`Your order <span class="hljs-subst">$&#123;id&#125;</span> will arrive in 20 minutes.`</span><br>  &#125;<br><br>  <span class="hljs-title function_">cancelOrder</span>(<span class="hljs-params">id</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orders</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">orders</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">order</span> =&gt;</span> order.<span class="hljs-property">id</span> !== id)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`You have canceled your order <span class="hljs-subst">$&#123;id&#125;</span>`</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>OrderManager</code>类中，我们可以访问<code>placeOrder</code>、<code>trackOrder</code>和<code>cancelOrder</code>方法。直接使用这些方法在JavaScript中是完全有效的！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> manager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderManager</span>();<br><br>manager.<span class="hljs-title function_">placeOrder</span>(<span class="hljs-string">&quot;Pad Thai&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>);<br>manager.<span class="hljs-title function_">trackOrder</span>(<span class="hljs-string">&quot;1234&quot;</span>);<br>manager.<span class="hljs-title function_">cancelOrder</span>(<span class="hljs-string">&quot;1234&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>然而，直接在管理器实例上调用方法也有不利之处。可能会出现这样的情况：我们决定稍后重命名某些方法，或者方法的功能发生变化。</p>
<p>比如说，我们不再称之为<code>placeOrder</code>，而是将其重命名为<code>addOrder</code>！这意味着我们必须确保在我们的代码库中任何地方都不调用<code>placeOrder</code>方法，这在较大的应用程序中可能会非常棘手。相反，我们希望将方法与管理器对象解耦，并为每个命令创建单独的命令函数！</p>
<p>让我们重构<code>OrderManager</code>类：它将不再具有<code>placeOrder</code>、<code>cancelOrder</code>和<code>trackOrder</code>方法，而是只有一个方法：<code>execute</code>。这个方法将执行任何给它的命令。</p>
<p>每个命令都应该可以访问管理器的订单，我们将订单作为其第一个参数传递给它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderManager</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orders</span> = [];<br>  &#125;<br><br>  <span class="hljs-title function_">execute</span>(<span class="hljs-params">command, ...args</span>) &#123;<br>    <span class="hljs-keyword">return</span> command.<span class="hljs-title function_">execute</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">orders</span>, ...args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们需要为订单管理器创建三个命令：</p>
<ul>
<li><code>PlaceOrderCommand</code></li>
<li><code>CancelOrderCommand</code></li>
<li><code>TrackOrderCommand</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">execute</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">execute</span> = execute;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">PlaceOrderCommand</span>(<span class="hljs-params">order, id</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>(<span class="hljs-function">(<span class="hljs-params">orders</span>) =&gt;</span> &#123;<br>    orders.<span class="hljs-title function_">push</span>(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`You have successfully ordered <span class="hljs-subst">$&#123;order&#125;</span> (<span class="hljs-subst">$&#123;id&#125;</span>)`</span>;<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CancelOrderCommand</span>(<span class="hljs-params">id</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>(<span class="hljs-function">(<span class="hljs-params">orders</span>) =&gt;</span> &#123;<br>    orders = orders.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">order</span>) =&gt;</span> order.<span class="hljs-property">id</span> !== id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`You have canceled your order <span class="hljs-subst">$&#123;id&#125;</span>`</span>;<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">TrackOrderCommand</span>(<span class="hljs-params">id</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">`Your order <span class="hljs-subst">$&#123;id&#125;</span> will arrive in 20 minutes.`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>太好了！现在的方法不再直接与<code>OrderManager</code>实例耦合，而是变成了独立的、解耦的函数，我们可以通过<code>OrderManager</code>上的<code>execute</code>方法来调用它们。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderManager</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orders</span> = [];<br>  &#125;<br><br>  <span class="hljs-title function_">execute</span>(<span class="hljs-params">command, ...args</span>) &#123;<br>    <span class="hljs-keyword">return</span> command.<span class="hljs-title function_">execute</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">orders</span>, ...args);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">execute</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">execute</span> = execute;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">PlaceOrderCommand</span>(<span class="hljs-params">order, id</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>(<span class="hljs-function"><span class="hljs-params">orders</span> =&gt;</span> &#123;<br>    orders.<span class="hljs-title function_">push</span>(id);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`You have successfully ordered <span class="hljs-subst">$&#123;order&#125;</span> (<span class="hljs-subst">$&#123;id&#125;</span>)`</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CancelOrderCommand</span>(<span class="hljs-params">id</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>(<span class="hljs-function"><span class="hljs-params">orders</span> =&gt;</span> &#123;<br>    orders = orders.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">order</span> =&gt;</span> order.<span class="hljs-property">id</span> !== id);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`You have canceled your order <span class="hljs-subst">$&#123;id&#125;</span>`</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">TrackOrderCommand</span>(<span class="hljs-params">id</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>(<span class="hljs-function">() =&gt;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Your order <span class="hljs-subst">$&#123;id&#125;</span> will arrive in 20 minutes.`</span>)<br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> manager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderManager</span>();<br><br>manager.<span class="hljs-title function_">execute</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PlaceOrderCommand</span>(<span class="hljs-string">&quot;Pad Thai&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>));<br>manager.<span class="hljs-title function_">execute</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TrackOrderCommand</span>(<span class="hljs-string">&quot;1234&quot;</span>));<br>manager.<span class="hljs-title function_">execute</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CancelOrderCommand</span>(<span class="hljs-string">&quot;1234&quot;</span>));<br></code></pre></td></tr></table></figure>

<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>命令模式允许我们将执行操作的方法与执行对象解耦。如果你正在处理具有一定生命周期的命令，或者排队并且在特定时间执行的命令，它可以让你更好的控制。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>命令模式的使用场景相当有限，而且通常会给应用程序增加不必要的样板代码。</p>
]]></content>
      <categories>
        <category>Patterns</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode215</title>
    <url>/posts/acdeee82.html</url>
    <content><![CDATA[<h3 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<p>示例 1:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,1,5,6,4], k = 2</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">3,2,3,1</span>,<span class="hljs-number">2,4,5,5</span>,<span class="hljs-number">6</span>], k = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array">https://leetcode.cn/problems/kth-largest-element-in-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">快速排序每次可以将一个数归位，并且拆成2半，左边都小于右边<br>如果位置大于k,在左侧继续快排<br>如果位置小于k,在右侧继续快排<br>如果位置等于k,返回<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">arr: <span class="hljs-built_in">number</span>[], l: <span class="hljs-built_in">number</span>, r: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">i: <span class="hljs-built_in">number</span>, j: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">let</span> temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> pivot = arr[r];<br>  <span class="hljs-keyword">let</span> i = l; <span class="hljs-comment">// 双指针(隔板) i的左侧都大于pivot</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = l; j &lt;= r; j++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[j] &gt; pivot) &#123;<br>      <span class="hljs-title function_">swap</span>(i, j);<br>      i++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">swap</span>(r, i);<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], k: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> kIdx = k - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">recur</span>(<span class="hljs-params">l: <span class="hljs-built_in">number</span>, r: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">let</span> pidx = <span class="hljs-title function_">partition</span>(nums, l, r);<br><br>    <span class="hljs-keyword">if</span> (pidx === kIdx) <span class="hljs-keyword">return</span> nums[pidx];<br>    <span class="hljs-keyword">if</span> (pidx &lt; kIdx) <span class="hljs-keyword">return</span> <span class="hljs-title function_">recur</span>(pidx + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-keyword">if</span> (pidx &gt; kIdx) <span class="hljs-keyword">return</span> <span class="hljs-title function_">recur</span>(l, pidx - <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">recur</span>(<span class="hljs-number">0</span>, nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode234</title>
    <url>/posts/e9efbc96.html</url>
    <content><![CDATA[<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/description/">234. 回文链表</a></h3><p>给你一个单链表的头节点 head ，请你判断该链表是否为<br>回文链表<br>。如果是，返回 true ；否则，返回 false 。</p>
<p>示例 1：<br>输入：head &#x3D; [1,2,2,1]<br>输出：true</p>
<p>示例 2：<br>输入：head &#x3D; [1,2]<br>输出：false</p>
<p>提示：<br>链表中节点数目在范围[1, 105] 内0 &lt;&#x3D; Node.val &lt;&#x3D; 9<br>进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> slow = head<br>    <span class="hljs-keyword">let</span> fast = head<br>    <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">while</span> (fast?.<span class="hljs-property">next</span>) &#123;<br>        fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span><br><br>        <span class="hljs-comment">// 前半部边走边逆序</span><br>        <span class="hljs-keyword">let</span> slowNext = slow.<span class="hljs-property">next</span><br><br>        slow.<span class="hljs-property">next</span> = pre<br>        pre = slow<br>        slow = slowNext<br>    &#125;<br><br>    <span class="hljs-comment">// 如果长度为奇数，fast 存在停留在最后节点，如果为偶数，fast null停留在最后节点后一个</span><br>    <span class="hljs-comment">// 走过次数是 长度/2 下取整</span><br>    <span class="hljs-comment">// 长度偶数：slow停留在中间，slow.next是右边还没翻转</span><br>    <span class="hljs-comment">// 长度奇数：slow停留在右边开头</span><br>    <span class="hljs-keyword">let</span> lhead = pre<br>    <span class="hljs-keyword">let</span> rhead = fast ? slow.<span class="hljs-property">next</span> : slow<br><br>    <span class="hljs-keyword">while</span> (lhead || rhead) &#123;<br>        <span class="hljs-keyword">if</span> (lhead?.<span class="hljs-property">val</span> !== rhead?.<span class="hljs-property">val</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (lhead) lhead = lhead.<span class="hljs-property">next</span><br>        <span class="hljs-keyword">if</span> (rhead) rhead = rhead.<span class="hljs-property">next</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode239</title>
    <url>/posts/975ec02b.html</url>
    <content><![CDATA[<h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h3><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 滑动窗口中的最大值 。</p>
<p>示例 1：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">输入：nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3<br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5<br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1]</span>, k = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/sliding-window-maximum">https://leetcode.cn/problems/sliding-window-maximum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">单调栈，栈中存储元素下标，如果栈底元素不在窗口内删掉<br>单调栈特性，栈底是最大值，栈顶是左侧第一个更大值<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxSlidingWindow</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], k: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">stack</span>: <span class="hljs-built_in">number</span>[] = []; <span class="hljs-comment">// 下标单调栈</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: <span class="hljs-built_in">number</span>[] = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>; r &lt; nums.<span class="hljs-property">length</span>; r++) &#123;<br>    <span class="hljs-keyword">let</span> l = r - k + <span class="hljs-number">1</span>; <span class="hljs-comment">// [l, r] 闭区间窗口长度k，r-l+1=k</span><br>    <span class="hljs-keyword">if</span> (stack[<span class="hljs-number">0</span>] &lt; l) stack.<span class="hljs-title function_">shift</span>();<br>    <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &amp;&amp; nums[stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]] &lt;= nums[r]) &#123;<br>      stack.<span class="hljs-title function_">pop</span>();<br>    &#125;<br>    stack.<span class="hljs-title function_">push</span>(r);<br>    <span class="hljs-keyword">if</span> (l &gt;= <span class="hljs-number">0</span>) &#123;<br>      res.<span class="hljs-title function_">push</span>(nums[stack[<span class="hljs-number">0</span>]]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode28</title>
    <url>/posts/14a10a9c.html</url>
    <content><![CDATA[<h3 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></h3><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p>
<p>示例 1：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><code class="hljs tap">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;<br>输出：0<br>解释：&quot;sad&quot; 在下标<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 6 </span>处匹配。<br>第一个匹配项的下标是<span class="hljs-number"> 0 </span>，所以返回<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;leeto&quot;</span><br>输出：-<span class="hljs-number">1</span><br>解释：<span class="hljs-string">&quot;leeto&quot;</span> 没有在 <span class="hljs-string">&quot;leetcode&quot;</span> 中出现，所以返回 -<span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><img src="/pic/no-match.png">
<img src="/pic/fast-skip.png">

<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc">f 在unshift -1之前的含义，f[i]表示包括i元素在内的s[0, i]最长前后缀长度<br>f 在unshift -1之后的含义，f[i]表示不包含i元素在内的s[0, i-1]最长前后缀长度, <br><span class="hljs-code">     i=0,0之前没有字符，没有前后缀，用-1特殊标识</span><br><span class="hljs-code">     i=1,1之前有1个字符，最长前后缀是0  abc这种不重复的序列区间，最长前后缀也是0</span><br>如果第i位不匹配时，<br><span class="hljs-code">	如果f[i]&gt;=0，将模式串向前滑动跳跃 =&gt; 模式串直接回退到f[i]位置，目标串指针不动，继续匹配</span><br><span class="hljs-code">	如果f[i]=-1, 将模式串向前滑动1 =&gt; 目标串指针右走1，模式串指针不动</span><br><span class="hljs-code">      i    </span><br>a b c d e f<br>a b c e<br><span class="hljs-section">      j</span><br><span class="hljs-section">-------</span><br><span class="hljs-code">      i</span><br>a b c d e f<br><span class="hljs-code">      a b c e</span><br><span class="hljs-code">      j</span><br><span class="hljs-section">模式串指针回退到0</span><br><span class="hljs-section">-------</span><br><span class="hljs-code">        i</span><br>a b c d e f<br><span class="hljs-code">        a b c e</span><br><span class="hljs-code">        j</span><br><span class="hljs-section">目标串指针向右走1</span><br><span class="hljs-section">-------</span><br></code></pre></td></tr></table></figure>
<img src="/pic/next-array.png">
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">求最长前后缀<br><span class="hljs-keyword">ab</span>...<span class="hljs-keyword">ab</span> --- <span class="hljs-keyword">ab</span>...<span class="hljs-keyword">ab</span> <br><span class="hljs-keyword">abc</span>..abe --- <span class="hljs-keyword">ab</span>...<span class="hljs-keyword">abc</span> <br><br>如果前后缀最后字符不匹配，再次寻找子串的前后缀，<br>根据前后相同的规律，虽然找了好几次前后缀，最前面的会等于最后面<br></code></pre></td></tr></table></figure>

<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">prefix</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">let</span> n = s.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>];<br><br>  <span class="hljs-keyword">let</span> f = [<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">let</span> t = f[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 不断缩短最长前后缀，让末尾相等，末尾是s[i]的最长前后缀</span><br>    <span class="hljs-keyword">while</span> (t &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] !== s[t]) &#123;<br>      t = f[t - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s[i] === s[t]) &#123;<br>      t++;<br>    &#125;<br>    f[i] = t;<br>  &#125;<br>  f.<span class="hljs-title function_">unshift</span>(-<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span>, m: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">if</span> (!s || !m) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">let</span> next = <span class="hljs-title function_">prefix</span>(m);<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>,<br>    j = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-property">length</span> &amp;&amp; j &lt; m.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">if</span> (s[i] === m[j]) &#123;<br>      i++;<br>      j++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next[j] === -<span class="hljs-number">1</span>) &#123;<br>      i++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      j = next[j];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> j === m.<span class="hljs-property">length</span> ? i - j : -<span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode3</title>
    <url>/posts/d83b9394.html</url>
    <content><![CDATA[<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters">https://leetcode.cn/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">维护一个无重复的窗口<br>如果重复就将左边的全裁掉 也去掉与自己相等的<br><br>注意<br><span class="hljs-string">&quot;abba&quot;</span><br><span class="hljs-keyword">bba </span> 把别人的重复包进去了， l 必须只能往前<br><br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> hash = &#123;&#125;; <span class="hljs-comment">// 字符: 最近出现的位置</span><br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>; r &lt; s.<span class="hljs-property">length</span>; r++) &#123;<br>    <span class="hljs-keyword">if</span> (s[r] <span class="hljs-keyword">in</span> hash) &#123;<br>      <span class="hljs-comment">// 注意max, l往前</span><br>      l = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(l, hash[s[r]] + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    hash[s[r]] = r;<br>    res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, r - l + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode322</title>
    <url>/posts/b0f96b84.html</url>
    <content><![CDATA[<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h3><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>示例 1：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><code class="hljs tap">输入：coins = [1, 2, 5], amount = 11<br>输出：3 <br>解释：11 =<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 5 </span>+ 1<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：coins </span>=<span class="hljs-string"> [2], amount = 3</span><br><span class="hljs-string">输出：-1</span><br></code></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：coins </span>=<span class="hljs-string"> [1], amount = 0</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/coin-change">https://leetcode.cn/problems/coin-change</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[i]</span> 表示随便拿硬币组成i，最少多少个<br>假设最后拿到一个coin, dp<span class="hljs-comment">[i-coin]</span>已知，dp<span class="hljs-comment">[i]</span>的一个局部最优解 dp<span class="hljs-comment">[i-coin]</span>+1<br>dp<span class="hljs-comment">[i]</span> = min (dp<span class="hljs-comment">[i-coins<span class="hljs-comment">[j]</span>]</span>+1)<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">coinChange</span>(<span class="hljs-params">coins: <span class="hljs-built_in">number</span>[], amount: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> dp = <span class="hljs-title class_">Array</span>(amount + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span>);<br>  dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= amount; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; coins.<span class="hljs-property">length</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (i &gt;= coins[j]) dp[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(dp[i], dp[i - coins[j]] + <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (dp[amount] === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> dp[amount];<br>&#125;<br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode34</title>
    <url>/posts/40c77f6.html</url>
    <content><![CDATA[<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<p>示例 1：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span>, target = 0<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">nums[<span class="hljs-built_in">mid</span>]&gt;=target 或者 nums[<span class="hljs-built_in">mid</span>]&gt;=nums[r]是解，求左边界<br>nums[<span class="hljs-built_in">mid</span>]&lt;=target 或者 nums[<span class="hljs-built_in">mid</span>]&lt;=nums[r]是解，求右边界<br>是解的时候，收缩边界不能+<span class="hljs-number">1</span>，<span class="hljs-number">-1</span>丢解<br><br>lbound  l进入目标区域后不动了，r还能动，r会继续收缩，直到l===r<br>lbound =&gt; l=<span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span><br>rbound  r进入目标区域后不动了，l还能动，l会继续收缩，直到l===r<br>rbound =&gt; r=<span class="hljs-built_in">mid</span><span class="hljs-number">-1</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">lbound</span>(<span class="hljs-params">l, r</span>) &#123;<br>	<span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>		let <span class="hljs-built_in">mid</span> = (l + r) &gt;&gt;&gt;<span class="hljs-number">1</span><br>		<span class="hljs-keyword">if</span>() r = <span class="hljs-built_in">mid</span><br>		<span class="hljs-keyword">else</span> l = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> l<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">rbound</span>(<span class="hljs-params">l, r</span>) &#123;<br>	<span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>		let <span class="hljs-built_in">mid</span> = (l + r + <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span> <span class="hljs-comment">// 因为减1</span><br>		<span class="hljs-keyword">if</span>() l = <span class="hljs-built_in">mid</span><br>		<span class="hljs-keyword">else</span> r = <span class="hljs-built_in">mid</span><span class="hljs-number">-1</span>  <br>	&#125;<br>	<span class="hljs-keyword">return</span> l<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">searchRange</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] &#123;<br>  <span class="hljs-keyword">let</span> n = nums.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>];<br><br>  <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>,<br>    r = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-keyword">let</span> mid = (l + r) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) r = mid;<br>    <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> lbound = l;<br>  <span class="hljs-keyword">if</span> (nums[lbound] !== target) <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>];<br><br>  (l = <span class="hljs-number">0</span>), (r = n - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-keyword">let</span> mid = (l + r + <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) l = mid;<br>    <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">let</span> rbound = l;<br><br>  <span class="hljs-keyword">return</span> [lbound, rbound];<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode300</title>
    <url>/posts/c46d417b.html</url>
    <content><![CDATA[<h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>示例 1：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[0,1,0,3,2,3]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,7,7,7,7,7,7]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-increasing-subsequence">https://leetcode.cn/problems/longest-increasing-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">dp<span class="hljs-selector-attr">[i]</span> 表示以i位置为结尾，最长子序列长度<br><span class="hljs-number">0</span>到i-<span class="hljs-number">1</span>中比nums<span class="hljs-selector-attr">[i]</span>小的，和i组成子序列，长度dp<span class="hljs-selector-attr">[j]</span>+<span class="hljs-number">1</span>，满足递增条件<br>dp<span class="hljs-selector-attr">[i]</span> = <span class="hljs-built_in">max</span>(dp<span class="hljs-selector-attr">[j]</span>+<span class="hljs-number">1</span>)<br><br>所有dp<span class="hljs-selector-attr">[i]</span>的最大值是解<br><br>dp<span class="hljs-selector-attr">[i]</span>=<span class="hljs-number">1</span>  自己长度为<span class="hljs-number">1</span>的序列<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lengthOfLIS</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> n = nums.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> dp = <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">1</span>);<br><br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>      <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>        dp[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>    res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, dp[i]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br> <br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode347</title>
    <url>/posts/3e6511dc.html</url>
    <content><![CDATA[<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p>
<p>示例 1:</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[1,1,1,2,2,3]</span>, k = 2<br>输出: <span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[1]</span>, k = 1<br>输出: <span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/top-k-frequent-elements">https://leetcode.cn/problems/top-k-frequent-elements</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">先求第k个频率是多少<br>然后找到大于等于频率k的所有元素<br><br>先预处理频率 hash表<br>对频率进行排序，找到第k大<br><span class="hljs-function"><span class="hljs-title">O</span><span class="hljs-params">(n)</span></span>的排序=&gt;桶排序<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">topKFrequent</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], k: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] &#123;<br>  <span class="hljs-keyword">let</span> n = nums.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">hash</span>: &#123; [<span class="hljs-attr">k</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span> &#125; = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    hash[nums[i]] = (hash[nums[i]] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 求第k大频率，桶排序。频率最小0，最大n</span><br>  <span class="hljs-keyword">let</span> buckets = <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> freq <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(hash)) &#123;<br>    buckets[freq]++;<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">kthFreq</span>: <span class="hljs-built_in">number</span> = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    k -= buckets[i];<br>    <span class="hljs-keyword">if</span> (k === <span class="hljs-number">0</span>) &#123;<br>      kthFreq = i;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 频率为k的元素结果</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: <span class="hljs-built_in">number</span>[] = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> hash) &#123;<br>    <span class="hljs-keyword">if</span> (hash[i] &gt;= kthFreq) &#123;<br>      res.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Number</span>(i));<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode35</title>
    <url>/posts/730b4760.html</url>
    <content><![CDATA[<h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
<p>示例 1:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 5</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 2</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 7</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/search-insert-position">https://leetcode.cn/problems/search-insert-position</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">nums<span class="hljs-comment">[mid]</span>&gt;=target可能是解，所有解的左边界<br>二分搜索是闭区间<span class="hljs-comment">[l,r]</span>，区间外的解要特判<br>空数组，插入到最后位置的情况<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> n = nums.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-comment">// []</span><br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// [1,2,3] 4</span><br>  <span class="hljs-keyword">if</span> (nums[n - <span class="hljs-number">1</span>] &lt; target) &#123;<br>    <span class="hljs-keyword">return</span> n;<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>,<br>    r = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-keyword">let</span> mid = (l + r) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) r = mid;<br>    <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> l;<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode395</title>
    <url>/posts/65c50ebd.html</url>
    <content><![CDATA[<h3 id="395-至少有-K-个重复字符的最长子串"><a href="#395-至少有-K-个重复字符的最长子串" class="headerlink" title="395. 至少有 K 个重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></h3><p>给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。</p>
<p>示例 1：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;aaabb&quot;</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：最长子串为 <span class="hljs-string">&quot;aaa&quot;</span> ，其中 &#x27;a&#x27; 重复了 <span class="hljs-number">3</span> 次。<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;ababbc&quot;</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span><br>解释：最长子串为 <span class="hljs-string">&quot;ababb&quot;</span> ，其中 &#x27;a&#x27; 重复了 <span class="hljs-number">2</span> 次， &#x27;b&#x27; 重复了 <span class="hljs-number">3</span> 次。<br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters">https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">预处理 字符:次数 map<br>    ____<span class="hljs-comment">(s1)</span>                  _<span class="hljs-comment">(次数小于k)</span>  ____<span class="hljs-comment">(s2)</span>                     _<span class="hljs-comment">(次数小于k)</span><br>s<span class="hljs-number">1</span>  __<span class="hljs-comment">(res)</span><span class="hljs-comment">(次数小于k)</span>__<span class="hljs-comment">(res)</span>               s<span class="hljs-number">2</span>  __<span class="hljs-comment">(res)</span><span class="hljs-comment">(次数小于k)</span>__<span class="hljs-comment">(res)</span><br>                                           <br><br>分治，递归的想法<br>找到<span class="hljs-number">1</span>个次数小于k，将字符串切成多个部分<br>假设每个部分字符串求解出结果, 当前字符串的解就是所有部分解的max<br></code></pre></td></tr></table></figure>


<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">longestSubstring</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span>, k: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">recur</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">let</span> hash = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> s) &#123;<br>      hash[c] = (hash[c] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> sep = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c <span class="hljs-keyword">in</span> hash) &#123;<br>      <span class="hljs-keyword">if</span> (hash[c] &lt; k) &#123;<br>        sep = c;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果所有字符次数都大于k</span><br>    <span class="hljs-keyword">if</span> (!sep) <span class="hljs-keyword">return</span> s.<span class="hljs-property">length</span>;<br><br>    <span class="hljs-keyword">let</span> res = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> parts = s.<span class="hljs-title function_">split</span>(sep);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> part <span class="hljs-keyword">of</span> parts) &#123;<br>      res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, <span class="hljs-title function_">recur</span>(part));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">recur</span>(s);<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode40</title>
    <url>/posts/4c202528.html</url>
    <content><![CDATA[<h3 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h3><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用 一次 。</p>
<p>注意：解集不能包含重复的组合。 </p>
<p>示例 1:</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[10,1,2,7,6,1,5]</span>, target = 8,<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,1,6]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,5]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,7]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[2,6]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2,5,2,1,2]</span>, target = 5,<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,2]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[5]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/combination-sum-ii">https://leetcode.cn/problems/combination-sum-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><img src="/pic/select-repeat.png"/>

<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">组合，每次将位置更大的分叉出来<br>12*选了，12&#x27;就可以剪枝<br>让相同的元素靠在一起，如果发现 nums<span class="hljs-comment">[i]</span> == nums<span class="hljs-comment">[i-1]</span>，则跳过<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">combinationSum2</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[][] &#123;<br>  <span class="hljs-keyword">let</span> n = nums.<span class="hljs-property">length</span>;<br>  <span class="hljs-comment">// 排序</span><br>  nums.<span class="hljs-title function_">sort</span>();<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">path</span>: <span class="hljs-built_in">number</span>[] = [];<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: <span class="hljs-built_in">number</span>[][] = [];<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">start, pathsum</span>) &#123;<br>    <span class="hljs-keyword">if</span> (pathsum &gt;= target) &#123;<br>      <span class="hljs-keyword">if</span> (pathsum === target) &#123;<br>        res.<span class="hljs-title function_">push</span>([...path]);<br>      &#125;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      path.<span class="hljs-title function_">push</span>(nums[i]);<br>      <span class="hljs-title function_">dfs</span>(i + <span class="hljs-number">1</span>, pathsum + nums[i]);<br>      path.<span class="hljs-title function_">pop</span>();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode42</title>
    <url>/posts/a22e4404.html</url>
    <content><![CDATA[<h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>示例 1：<br><img src="/pic/rainwatertrap.png" /></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/trapping-rain-water">https://leetcode.cn/problems/trapping-rain-water</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">能存多少水=&gt;每个位置能存多少水的和<br>一个位置能存多少水=&gt;<span class="hljs-built_in">min</span>(左边最高，右边最高)-自己高度<br>如果从右往左，左边最高知道，右边最高怎么办？<br>如果右边有高度大于左边最高，一个位置能存多少水=&gt;左边最高-自己高度<br><br>l从左往右，r从右往左<br><span class="hljs-built_in">lmax</span>记录l的左边最高，rmax记录r的右边最高<br><br>如果右边有高度大于左边最高和l，l位置可以计算解 r不动<br>	如果<span class="hljs-built_in">height</span>[l]&gt;=<span class="hljs-built_in">lmax</span> res+=<span class="hljs-number">0</span> l++ 更新<span class="hljs-built_in">lmax</span><br>	如果<span class="hljs-built_in">height</span>[l]&lt;<span class="hljs-built_in">lmax</span>  res+=左边最高-自己高度 l++<br>        <br>如果左边有高度大于右边最高和r, r位置可以计算解 l不动<br>	如果<span class="hljs-built_in">height</span>[r]&gt;=rmax res+=<span class="hljs-number">0</span> r-- 更新rmax<br>	如果<span class="hljs-built_in">height</span>[r]&lt;rmax  res+=右边最高-自己高度 r--<br><br><span class="hljs-keyword">if</span>(rmax &gt;= <span class="hljs-built_in">lmax</span>)&#123;<br>    走出这个分支路径说明，<span class="hljs-built_in">height</span>[l]成为新<span class="hljs-built_in">lmax</span>，<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    走出这个分支路径说明，<span class="hljs-built_in">height</span>[r]成为新rmax<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trap</span>(<span class="hljs-params">height: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> n = height.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>,<br>    r = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> lmax = height[l],<br>    rmax = height[r];<br>    <span class="hljs-comment">// 注意l===r也要走，因为每次计算当前位置存水量后走到下一个位置，下一个位置没计算呢</span><br>  <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>    <span class="hljs-keyword">if</span> (rmax &gt;= lmax) &#123;<br>      <span class="hljs-keyword">if</span> (height[l] &gt;= lmax) &#123;<br>        lmax = height[l];<br>        res += <span class="hljs-number">0</span>;<br>        l++;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        res += lmax - height[l];<br>        l++;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (height[r] &gt;= rmax) &#123;<br>        rmax = height[r];<br>        res += <span class="hljs-number">0</span>;<br>        r--;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        res += rmax - height[r];<br>        r--;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode430</title>
    <url>/posts/ea0f043d.html</url>
    <content><![CDATA[<h3 id="430-扁平化多级双向链表"><a href="#430-扁平化多级双向链表" class="headerlink" title="430. 扁平化多级双向链表"></a><a href="https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list/description/">430. 扁平化多级双向链表</a></h3><p>你会得到一个双链表，其中包含的节点有一个下一个指针、一个前一个指针和一个额外的 子指针 。这个子指针可能指向一个单独的双向链表，也包含这些特殊的节点。这些子列表可以有一个或多个自己的子列表，以此类推，以生成如下面的示例所示的 多层数据结构 。</p>
<p>给定链表的头节点 head ，将链表 扁平化 ，以便所有节点都出现在单层双链表中。让 curr 是一个带有子列表的节点。子列表中的节点应该出现在扁平化列表中的 curr 之后 和 curr.next 之前 。</p>
<p>返回 扁平列表的 head 。列表中的节点必须将其 所有 子指针设置为 null 。</p>
<p>示例 1：<br>输入：head &#x3D; [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]<br>输出：[1,2,3,7,8,11,12,9,10,4,5,6]<br>解释：输入的多级列表如上图所示。<br>扁平化后的链表如下图：</p>
<p>示例 2：<br>输入：head &#x3D; [1,2,null,3]<br>输出：[1,3,2]<br>解释：输入的多级列表如上图所示。<br>扁平化后的链表如下图：</p>
<p>示例 3：<br>输入：head &#x3D; []<br>输出：[]<br>说明：输入中可能存在空列表。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // Definition for a _Node.</span><br><span class="hljs-comment"> * function _Node(val,prev,next,child) &#123;</span><br><span class="hljs-comment"> *    this.val = val;</span><br><span class="hljs-comment"> *    this.prev = prev;</span><br><span class="hljs-comment"> *    this.next = next;</span><br><span class="hljs-comment"> *    this.child = child;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">_Node</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">_Node</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> flatten = <span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> p = head<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-keyword">if</span> (p.<span class="hljs-property">child</span>) &#123;<br>            <span class="hljs-comment">// 先递归处理完子链表</span><br>            <span class="hljs-keyword">let</span> child = <span class="hljs-title function_">flatten</span>(p.<span class="hljs-property">child</span>)<br>            <span class="hljs-keyword">let</span> next = p.<span class="hljs-property">next</span><br><br>            <span class="hljs-comment">// 前半部连接</span><br>            p.<span class="hljs-property">next</span> = child<br>            child.<span class="hljs-property">prev</span> = p<br>            p.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span><br><br>            <span class="hljs-comment">// 后半部连接</span><br>            <span class="hljs-keyword">if</span> (next) &#123;<br>                <span class="hljs-keyword">while</span> (child.<span class="hljs-property">next</span>) &#123;<br>                    child = child.<span class="hljs-property">next</span><br>                &#125;<br>                child.<span class="hljs-property">next</span> = next<br>                next.<span class="hljs-property">prev</span> = child<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p = p.<span class="hljs-property">next</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> head<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode433</title>
    <url>/posts/73065587.html</url>
    <content><![CDATA[<h3 id="433-最小基因变化"><a href="#433-最小基因变化" class="headerlink" title="433. 最小基因变化"></a><a href="https://leetcode.cn/problems/minimum-genetic-mutation/description/">433. 最小基因变化</a></h3><p>基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 ‘A’、’C’、’G’ 和 ‘T’ 之一。</p>
<p>假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。</p>
<p>例如，”AACCGGTT” –&gt; “AACCGGTA” 就是一次基因变化。<br>另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 bank 中）</p>
<p>给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。</p>
<p>注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。</p>
<p>示例 1：<br>输入：start &#x3D; “AACCGGTT”, end &#x3D; “AACCGGTA”, bank &#x3D; [“AACCGGTA”]<br>输出：1</p>
<p>示例 2：<br>输入：start &#x3D; “AACCGGTT”, end &#x3D; “AAACGGTA”, bank &#x3D; [“AACCGGTA”,”AACCGCTA”,”AAACGGTA”]<br>输出：2</p>
<p>示例 3：<br>输入：start &#x3D; “AAAAACCC”, end &#x3D; “AACCCCCC”, bank &#x3D; [“AAAACCCC”,”AAACCCCC”,”AACCCCCC”]<br>输出：3</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">startGene</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">endGene</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string[]</span>&#125; <span class="hljs-variable">bank</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minMutation = <span class="hljs-keyword">function</span> (<span class="hljs-params">startGene, endGene, bank</span>) &#123;<br>    <span class="hljs-keyword">let</span> queue = [startGene]<br>    <span class="hljs-keyword">let</span> used = <span class="hljs-title class_">Array</span>(bank.<span class="hljs-property">length</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>)<br>    used[startGene] = <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">let</span> step = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span>) &#123;<br>        step++ <span class="hljs-comment">// 一次一层，n个</span><br><br>        <span class="hljs-keyword">let</span> n = queue.<span class="hljs-property">length</span><br>        <span class="hljs-keyword">while</span> (n--) &#123;<br>            <span class="hljs-keyword">let</span> cur = queue.<span class="hljs-title function_">shift</span>()<br><br>            <span class="hljs-comment">// 找1跳可达，防止死循环，用过的不能再用</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> g <span class="hljs-keyword">of</span> bank) &#123;<br>                <span class="hljs-keyword">if</span>(used[g])&#123;<br>                    <span class="hljs-comment">// 用过的剪掉</span><br>                    <span class="hljs-keyword">continue</span><br>                &#125;<br><br>                <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; g.<span class="hljs-property">length</span>; i++) &#123;<br>                    <span class="hljs-keyword">if</span> (cur[i] !== g[i]) &#123;<br>                        count++<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (count === <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (g === endGene) &#123;<br>                        <span class="hljs-keyword">return</span> step<br>                    &#125;<br>                    used[g] = <span class="hljs-literal">true</span><br>                    queue.<span class="hljs-title function_">push</span>(g)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode445</title>
    <url>/posts/d5246675.html</url>
    <content><![CDATA[<h3 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a><a href="https://leetcode.cn/problems/add-two-numbers-ii/description/">445. 两数相加 II</a></h3><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p>示例1：<br>输入：l1 &#x3D; [7,2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,8,0,7]</p>
<p>示例2：<br>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[8,0,7]</p>
<p>示例3：<br>输入：l1 &#x3D; [0], l2 &#x3D; [0]<br>输出：[0]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-keyword">function</span> (<span class="hljs-params">l1, l2</span>) &#123;<br>    <span class="hljs-keyword">let</span> len1 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> len2 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> p1 = l1<br>    <span class="hljs-keyword">while</span> (p1) &#123;<br>        len1++<br>        p1 = p1.<span class="hljs-property">next</span><br>    &#125;<br><br>    <span class="hljs-keyword">let</span> p2 = l2<br>    <span class="hljs-keyword">while</span> (p2) &#123;<br>        len2++<br>        p2 = p2.<span class="hljs-property">next</span><br>    &#125;<br><br>    <span class="hljs-keyword">let</span> dummyHead = &#123; <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> &#125;<br><br>    <span class="hljs-comment">// 返回加完后的进位</span><br>    <span class="hljs-comment">// 从底部构建新链表</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">recur</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 递归出口</span><br>        <span class="hljs-keyword">if</span> (!len1 &amp;&amp; !len2) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br>        <span class="hljs-comment">// 最后面的先算完，再计算当前，递归</span><br>        <span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span><br>        <span class="hljs-comment">// 当前是0还是值，看2个长度是否相等，短的是0</span><br>        <span class="hljs-keyword">if</span> (len1 &lt; len2) &#123;<br>            cur += l2.<span class="hljs-property">val</span><br><br>            l2 = l2.<span class="hljs-property">next</span><br>            len2--<br>            <span class="hljs-keyword">let</span> over = <span class="hljs-title function_">recur</span>()<br>            cur += over<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len1 &gt; len2) &#123;<br>            cur += l1.<span class="hljs-property">val</span><br><br>            l1 = l1.<span class="hljs-property">next</span><br>            len1--<br>            <span class="hljs-keyword">let</span> over = <span class="hljs-title function_">recur</span>()<br>            cur += over<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur += l1.<span class="hljs-property">val</span><br>            cur += l2.<span class="hljs-property">val</span><br><br>            l1 = l1.<span class="hljs-property">next</span><br>            l2 = l2.<span class="hljs-property">next</span><br>            len1--<br>            len2--<br>            <span class="hljs-keyword">let</span> over = <span class="hljs-title function_">recur</span>()<br>            cur += over<br>        &#125;<br><br>        <span class="hljs-keyword">let</span> nextOver = ~~(cur / <span class="hljs-number">10</span>)<br>        cur = cur % <span class="hljs-number">10</span><br><br>        <span class="hljs-comment">// 挂载当前节点到新链表 头部</span><br>        <span class="hljs-keyword">let</span> curNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(cur)<br>        curNode.<span class="hljs-property">next</span> = dummyHead.<span class="hljs-property">next</span><br>        dummyHead.<span class="hljs-property">next</span> = curNode<br><br>        <span class="hljs-keyword">return</span> nextOver<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> lastOver = <span class="hljs-title function_">recur</span>()<br>    <span class="hljs-comment">// 注意最后一个进位</span><br>    <span class="hljs-keyword">if</span>(lastOver!==<span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-keyword">let</span> curNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(lastOver)<br>        curNode.<span class="hljs-property">next</span> = dummyHead.<span class="hljs-property">next</span><br>        dummyHead.<span class="hljs-property">next</span> = curNode<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummyHead.<span class="hljs-property">next</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode46</title>
    <url>/posts/a543801d.html</url>
    <content><![CDATA[<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h3><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<p>示例 1：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/permutations">https://leetcode.cn/problems/permutations</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><img src="/pic/permute.png" />

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">每次分叉出来的，除了当前路径选过的，其他都可以选<br>used 记录选过的，不能再选<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[][] &#123;<br>  <span class="hljs-keyword">if</span> (!nums.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> [];<br><br>  <span class="hljs-keyword">let</span> n = nums.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: <span class="hljs-built_in">number</span>[][] = [];<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">path</span>: <span class="hljs-built_in">number</span>[] = [];<br>  <span class="hljs-keyword">let</span> used = <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (i === n) &#123;<br>      res.<span class="hljs-title function_">push</span>([...path]);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>      <span class="hljs-keyword">if</span> (!used[j]) &#123;<br>        path.<span class="hljs-title function_">push</span>(nums[j]);<br>        used[j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-title function_">dfs</span>(i + <span class="hljs-number">1</span>);<br>        path.<span class="hljs-title function_">pop</span>();<br>        used[j] = <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">dfs</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode47</title>
    <url>/posts/d244b08b.html</url>
    <content><![CDATA[<h3 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h3><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
<p>示例 1：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/permutations-ii">https://leetcode.cn/problems/permutations-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><img src="/pic/permute-repeat.png"/>

<figure class="highlight matlab"><table><tr><td class="code"><pre><code class="hljs matlab">固定相同的元素在排列中的相对位置，排序<br>只保留位次递增的序列，其余序列都可以剪枝<br><span class="hljs-number">122</span>&#x27;<span class="hljs-number">2</span>&#x27;&#x27;  可以删掉<span class="hljs-number">12</span>&#x27;<span class="hljs-number">22</span>&#x27;&#x27; <span class="hljs-number">12</span>&#x27;&#x27;<span class="hljs-number">2</span>&#x27;<span class="hljs-number">2</span>  <span class="hljs-number">12</span>&#x27;<span class="hljs-number">2</span>&#x27;&#x27;<span class="hljs-number">2</span> <span class="hljs-number">12</span>&#x27;&#x27;<span class="hljs-number">22</span>&#x27;等<br>如何判断重复元素里有部分逆序？<br>当前位置<span class="hljs-built_in">i</span>, 如果<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>没有使用过, 说明<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>后面才用，有逆序<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">permuteUnique</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[][] &#123;<br>  <span class="hljs-keyword">if</span> (!nums.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> [];<br><br>  <span class="hljs-comment">// 排序</span><br>  nums.<span class="hljs-title function_">sort</span>();<br><br>  <span class="hljs-keyword">let</span> n = nums.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: <span class="hljs-built_in">number</span>[][] = [];<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">path</span>: <span class="hljs-built_in">number</span>[] = [];<br>  <span class="hljs-keyword">let</span> used = <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (i === n) &#123;<br>      res.<span class="hljs-title function_">push</span>([...path]);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>      <span class="hljs-comment">// 只保留第一个位次递增序列，其余剪枝</span><br>      <span class="hljs-comment">// 递增序列特点，前一个used为true</span><br>      <span class="hljs-comment">// 如果i-1没有使用过说明有逆序</span><br>      <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; nums[j] === nums[j - <span class="hljs-number">1</span>] &amp;&amp; !used[j - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-comment">// 剪枝</span><br>      <span class="hljs-keyword">if</span> (used[j]) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      path.<span class="hljs-title function_">push</span>(nums[j]);<br>      used[j] = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">dfs</span>(i + <span class="hljs-number">1</span>);<br>      path.<span class="hljs-title function_">pop</span>();<br>      used[j] = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">dfs</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode503</title>
    <url>/posts/59e96c73.html</url>
    <content><![CDATA[<h3 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h3><p>给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。</p>
<p>数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。</p>
<p>示例 1:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,2,1]</span><br><span class="hljs-section">输出: [2,-1,2]</span><br><span class="hljs-section">解释: 第一个 1 的下一个更大的数是 2；</span><br>数字 2 找不到下一个更大的数； <br>第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br></code></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[1,2,3,4,3]</span><br>输出: <span class="hljs-string">[2,3,4,-1,4]</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/next-greater-element-ii">https://leetcode.cn/problems/next-greater-element-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">循环数组展开为两个数组，从左到右维护一个单调栈，栈顶就是下一个更大的元素<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">nextGreaterElements</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span>[] &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">stack</span>: <span class="hljs-built_in">number</span>[] = [];<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: <span class="hljs-built_in">number</span>[] = [];<br>  <span class="hljs-keyword">let</span> n = nums.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">let</span> position = i % n;<br>    <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &amp;&amp; stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] &lt;= nums[position]) &#123;<br>      stack.<span class="hljs-title function_">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &lt; n) &#123;<br>      res[i] = stack.<span class="hljs-property">length</span> ? stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] : -<span class="hljs-number">1</span>;<br>    &#125;<br>    stack.<span class="hljs-title function_">push</span>(nums[position]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode516</title>
    <url>/posts/3098a9bd.html</url>
    <content><![CDATA[<h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h3><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<p>示例 1：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;bbbab&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：一个可能的最长回文子序列为 <span class="hljs-string">&quot;bbbb&quot;</span> 。<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cbbd&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：一个可能的最长回文子序列为 <span class="hljs-string">&quot;bb&quot;</span> 。<br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-palindromic-subsequence">https://leetcode.cn/problems/longest-palindromic-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">dp<span class="hljs-selector-attr">[l]</span><span class="hljs-selector-attr">[r]</span> 表示从l到r的字符串，最长回文子序列<br><br>l r字符回文，分类讨论<br>如果s<span class="hljs-selector-attr">[l]</span>===s<span class="hljs-selector-attr">[r]</span>, dp<span class="hljs-selector-attr">[l+1]</span><span class="hljs-selector-attr">[r-1]</span>+<span class="hljs-number">2</span><br>如果s<span class="hljs-selector-attr">[l]</span>!==s<span class="hljs-selector-attr">[r]</span>, <span class="hljs-built_in">max</span>(dp<span class="hljs-selector-attr">[l+1]</span><span class="hljs-selector-attr">[r]</span>, dp<span class="hljs-selector-attr">[l]</span><span class="hljs-selector-attr">[r-1]</span>)<br>    <br>初始化<br>dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[i]</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">longestPalindromeSubseq</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> n = s.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> dp = <span class="hljs-title class_">Array</span>(n)<br>    .<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));<br><br>  <span class="hljs-comment">// 枚举字符串长度</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j + i &lt; n; j++) &#123;<br>      <span class="hljs-keyword">let</span> l = j,<br>        r = j + i;<br>      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) &#123;<br>        dp[l][r] = <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (s[l] === s[r]) &#123;<br>          dp[l][r] = dp[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          dp[l][r] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[l + <span class="hljs-number">1</span>][r], dp[l][r - <span class="hljs-number">1</span>]);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode518</title>
    <url>/posts/d72084ba.html</url>
    <content><![CDATA[<h3 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a></h3><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p>
<p>假设每一种面额的硬币有无限个。 </p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
<p>示例 1：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit"><br>输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2<span class="hljs-string">+2</span><span class="hljs-string">+1</span><br>5=2<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br>5=1<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br></code></pre></td></tr></table></figure>


<p>示例 2：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><code class="hljs tap"><br>输入：amount = 3, coins = [2]<br>输出：0<br>解释：只用面额<span class="hljs-number"> 2 </span>的硬币不能凑成总金额<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：amount </span>=<span class="hljs-string"> 10, coins = [10] </span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/coin-change-ii">https://leetcode.cn/problems/coin-change-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> 表示给看前i个硬币，组成数目j的方案数量<br><br>分类讨论<br>为了不包含重复解，分2种情况，一定包含第i个硬币，一定不包含第i个硬币 2种情况下都包含部分解<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=<br>+dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-coin]</span> 给看前i个硬币，组成数目j-coin 的方案数量 i不动还可以继续选<br>+dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span> 给看前i-1个硬币，组成数目j的方案数量<br><br>dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span>=1 给看前0个银币，组成数目0方案数量1<br>dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span>=0 给看前0个银币，组成数目i不是0的方案数量0<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">amount: <span class="hljs-built_in">number</span>, coins: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> n = coins.<span class="hljs-property">length</span>,<br>    m = amount;<br>  <span class="hljs-keyword">let</span> dp = <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>(m + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));<br>  dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) &#123;<br>      dp[i][j] += dp[i - <span class="hljs-number">1</span>][j];<br>      <span class="hljs-keyword">if</span> (j &gt;= coins[i - <span class="hljs-number">1</span>]) dp[i][j] += dp[i][j - coins[i - <span class="hljs-number">1</span>]];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">amount: <span class="hljs-built_in">number</span>, coins: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> n = coins.<span class="hljs-property">length</span>,<br>    m = amount;<br>  <span class="hljs-keyword">let</span> dp = <span class="hljs-title class_">Array</span>(m + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>  dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = coins[i - <span class="hljs-number">1</span>]; j &lt;= m; j++) &#123;<br>      dp[j] += dp[j - coins[i - <span class="hljs-number">1</span>]];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> dp[m];<br>&#125;<br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode560</title>
    <url>/posts/96ba9a4f.html</url>
    <content><![CDATA[<h3 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h3><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。</p>
<p>示例 1：</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,1,1], k = 2</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,2,3], k = 3</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/subarray-sum-equals-k">https://leetcode.cn/problems/subarray-sum-equals-k</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">预处理前缀和数组<br>从左往右遍历前缀和数组，当前位置的解<span class="hljs-operator">=</span>左侧位置中 前缀和为当前值-k的数量<br><br>只用考虑比当前前缀和小k的，比当前前缀和大k的情况，存在于后面位置的部分解<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">subarraySum</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], k: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> n = nums.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">let</span> sum = [<span class="hljs-number">0</span>]; <span class="hljs-comment">// padding一个0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    sum[i] = sum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> hash = &#123;&#125;;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>    res += (hash[sum[i] - k] || <span class="hljs-number">0</span>);<br>    hash[sum[i]] = (hash[sum[i]] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode523</title>
    <url>/posts/6bdf0ef1.html</url>
    <content><![CDATA[<h3 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a><a href="https://leetcode.cn/problems/continuous-subarray-sum/">523. 连续的子数组和</a></h3><p>给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p>
<p>子数组大小 至少为 2 ，且<br>子数组元素总和为 k 的倍数。<br>如果存在，返回 true ；否则，返回 false 。</p>
<p>如果存在一个整数 n ，令整数 x 符合 x &#x3D; n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。</p>
<p>示例 1：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[23,2,4,6,7]</span>, k = 6<br>输出：true<br>解释：<span class="hljs-comment">[2,4]</span> 是一个大小为 2 的子数组，并且和为 6 。<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><code class="hljs tap">输入：nums = [23,2,6,4,7], k = 6<br>输出：true<br>解释：[23, 2, 6, 4, 7] 是大小为<span class="hljs-number"> 5 </span>的子数组，并且和为<span class="hljs-number"> 42 </span>。 <br>42 是<span class="hljs-number"> 6 </span>的倍数，因为<span class="hljs-number"> 42 </span>=<span class="hljs-number"> 7 </span>*<span class="hljs-number"> 6 </span>且<span class="hljs-number"> 7 </span>是一个整数。<br></code></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">23</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">13</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/continuous-subarray-sum">https://leetcode.cn/problems/continuous-subarray-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">预处理一个前缀和数组，<span class="hljs-built_in">sum</span>[i]表示前i个元素的和<br><span class="hljs-built_in">sum</span>[j]-<span class="hljs-built_in">sum</span>[i] = <span class="hljs-built_in">n</span> * k<br>(a + <span class="hljs-built_in">n</span> * k) - a = <span class="hljs-built_in">n</span> * k<br>只要<span class="hljs-built_in">sum</span>[j]%k在之前出现过，并且数组长度大于<span class="hljs-number">1</span> =&gt; 前j个-前i个&gt;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkSubarraySum</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], k: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">let</span> n = nums.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">let</span> sum = [<span class="hljs-number">0</span>]; <span class="hljs-comment">// padding一个0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    sum[i] = sum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> hash = &#123;&#125;;<br>  hash[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">let</span> leftSum = sum[i] % k;<br>    <span class="hljs-keyword">if</span> (leftSum <span class="hljs-keyword">in</span> hash &amp;&amp; i - hash[leftSum] &gt; <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (hash[leftSum] === <span class="hljs-literal">undefined</span>) &#123;<br>      hash[leftSum] = i; <span class="hljs-comment">// 保留最远的</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode583</title>
    <url>/posts/9130e67b.html</url>
    <content><![CDATA[<h3 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h3><p>给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。</p>
<p>每步 可以删除任意一个字符串中的一个字符。</p>
<p>示例 1：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">word1</span> = <span class="hljs-string">&quot;sea&quot;</span>, <span class="hljs-attr">word2</span> = <span class="hljs-string">&quot;eat&quot;</span><br>输出: <span class="hljs-number">2</span><br>解释: 第一步将 <span class="hljs-string">&quot;sea&quot;</span> 变为 <span class="hljs-string">&quot;ea&quot;</span> ，第二步将 <span class="hljs-string">&quot;eat &quot;</span>变为 <span class="hljs-string">&quot;ea&quot;</span><br></code></pre></td></tr></table></figure>
<p>示例  2:</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">word1</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">word2</span> = <span class="hljs-string">&quot;etco&quot;</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/delete-operation-for-two-strings">https://leetcode.cn/problems/delete-operation-for-two-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> 表示给看word1前i个，word2前j个，最少删除多少可以相同<br><br><span class="hljs-selector-tag">i</span>,j结尾值分类讨论<br>如果word1<span class="hljs-selector-attr">[i]</span>===word2<span class="hljs-selector-attr">[j]</span>  dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span>=dp<span class="hljs-selector-attr">[i-1]</span><span class="hljs-selector-attr">[j-1]</span>  不删<br>如果word1<span class="hljs-selector-attr">[i]</span>!==word2<span class="hljs-selector-attr">[j]</span>  <span class="hljs-built_in">min</span>(dp<span class="hljs-selector-attr">[i-1]</span><span class="hljs-selector-attr">[j]</span>+<span class="hljs-number">1</span>, dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j-1]</span>+<span class="hljs-number">1</span>) 删<span class="hljs-number">1</span>个<br><br>初始化<br>dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[0]</span>=<span class="hljs-selector-tag">i</span>, dp<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[i]</span>=<span class="hljs-selector-tag">i</span><br><br>滚动数组空间优化<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">minDistance</span>(<span class="hljs-params">word1: <span class="hljs-built_in">string</span>, word2: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> n = word1.<span class="hljs-property">length</span>,<br>    m = word2.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> dp = <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>)<br>    .<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>(m + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) dp[i][<span class="hljs-number">0</span>] = i;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) dp[<span class="hljs-number">0</span>][j] = j;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>      <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] === word2[j - <span class="hljs-number">1</span>]) &#123;<br>        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br><br></code></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">minDistance</span>(<span class="hljs-params">word1: <span class="hljs-built_in">string</span>, word2: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> n = word1.<span class="hljs-property">length</span>,<br>    m = word2.<span class="hljs-property">length</span>;<br>  <span class="hljs-comment">// 空间优化</span><br>  <span class="hljs-keyword">let</span> dp = <span class="hljs-title class_">Array</span>(<span class="hljs-number">2</span>)<br>    .<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>(m + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) &#123;<br>      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span> || j === <span class="hljs-number">0</span>) &#123;<br>        dp[i % <span class="hljs-number">2</span>][j] = i + j;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] === word2[j - <span class="hljs-number">1</span>]) &#123;<br>        dp[i % <span class="hljs-number">2</span>][j] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j - <span class="hljs-number">1</span>];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        dp[i % <span class="hljs-number">2</span>][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j], dp[i % <span class="hljs-number">2</span>][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> dp[n % <span class="hljs-number">2</span>][m];<br>&#125;<br><br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode61</title>
    <url>/posts/911773c.html</url>
    <content><![CDATA[<h3 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><a href="https://leetcode.cn/problems/rotate-list/description/">61. 旋转链表</a></h3><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p>
<p>示例 1：<br>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[4,5,1,2,3]</p>
<p>示例 2：<br>输入：head &#x3D; [0,1,2], k &#x3D; 4<br>输出：[2,0,1]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> rotateRight = <span class="hljs-keyword">function</span> (<span class="hljs-params">head, k</span>) &#123;<br>    <span class="hljs-comment">// 注意k可能比总长度还大</span><br>    <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> p = head<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        total++<br>        p = p.<span class="hljs-property">next</span><br>    &#125;<br><br>    k = k % total<br>    <span class="hljs-keyword">if</span> (k === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br><br>    <span class="hljs-comment">// 快慢指针，找到倒数k元素前一个位置</span><br>    <span class="hljs-keyword">let</span> dummyHead = &#123; <span class="hljs-attr">next</span>: head &#125;<br>    <span class="hljs-keyword">let</span> fast = dummyHead<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        fast = fast.<span class="hljs-property">next</span><br>    &#125;<br><br>    <span class="hljs-keyword">let</span> slow = dummyHead<br>    <span class="hljs-keyword">while</span> (fast?.<span class="hljs-property">next</span>) &#123;<br>        slow = slow.<span class="hljs-property">next</span><br>        fast = fast.<span class="hljs-property">next</span><br>    &#125;<br><br>    <span class="hljs-comment">// 将后半部移动到最开头</span><br>    dummyHead.<span class="hljs-property">next</span> = slow.<span class="hljs-property">next</span><br>    fast.<span class="hljs-property">next</span> = head<br>    slow.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">return</span> dummyHead.<span class="hljs-property">next</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode75</title>
    <url>/posts/17678264.html</url>
    <content><![CDATA[<h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h3><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
<p>示例 1：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,0,2,1,1,0]</span><br>输出：<span class="hljs-string">[0,0,1,1,2,2]</span><br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,0,1]</span><br>输出：<span class="hljs-comment">[0,1,2]</span><br></code></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/sort-colors">https://leetcode.cn/problems/sort-colors</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">维护<span class="hljs-selector-tag">i</span>的左边不包括<span class="hljs-selector-tag">i</span>位置元素，都是<span class="hljs-number">0</span><br>维护k的右边不包括k位置元素，都是<span class="hljs-number">1</span><br>隔板<br><br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sortColors</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">i: <span class="hljs-built_in">number</span>, j: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">let</span> t = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = t;<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>,<br>    j = <span class="hljs-number">0</span>,<br>    k = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (j &lt;= k) &#123;<br>    <span class="hljs-keyword">let</span> current = nums[j];<br>    <span class="hljs-keyword">if</span> (current === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-title function_">swap</span>(i, j);<br>      i++;<br>      j++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current === <span class="hljs-number">1</span>) &#123;<br>      j++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">swap</span>(j, k);<br>      k--;<br>    &#125;<br>  &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode77</title>
    <url>/posts/f969e348.html</url>
    <content><![CDATA[<h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h3><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p>
<p>你可以按 任何顺序 返回答案。</p>
<p>示例 1：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">输入：n = 4, k = 2<br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/combinations">https://leetcode.cn/problems/combinations</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><img src="/pic/select.png" />

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">第一层表示第一个位置能选择1,2，3<br>选过1后的第二层，表示第二个位置能选择2,3<br><br>第一个位置选择了2，第二个位置只能选择3, 1的组合已经录入完了<br>组合就是  所有比它位置大的分叉出来<br></code></pre></td></tr></table></figure>



<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">n: <span class="hljs-built_in">number</span>, k: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[][] &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: <span class="hljs-built_in">number</span>[][] = [];<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">path</span>: <span class="hljs-built_in">number</span>[] = [];<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, len: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (len === k) &#123;<br>      res.<span class="hljs-title function_">push</span>([...path]);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt;= n; i++) &#123;<br>      path.<span class="hljs-title function_">push</span>(i);<br>      <span class="hljs-title function_">dfs</span>(i + <span class="hljs-number">1</span>, len + <span class="hljs-number">1</span>);<br>      path.<span class="hljs-title function_">pop</span>();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode82</title>
    <url>/posts/e9b0b08.html</url>
    <content><![CDATA[<h3 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/">82. 删除排序链表中的重复元素 II</a></h3><p>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p>
<p>示例 1：<br>输入：head &#x3D; [1,2,3,3,4,4,5]<br>输出：[1,2,5]</p>
<p>示例 2：<br>输入：head &#x3D; [1,1,1,2,3]<br>输出：[2,3]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> deleteDuplicates = <span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> dummyHead = &#123; <span class="hljs-attr">next</span>: head &#125;<br>    <span class="hljs-keyword">let</span> p = dummyHead <span class="hljs-comment">// 已处理完的链表的尾部</span><br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span> <span class="hljs-comment">// null也是1个节点，count算1</span><br>        <span class="hljs-keyword">let</span> cur = p.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">while</span> (cur &amp;&amp; cur.<span class="hljs-property">next</span>?.<span class="hljs-property">val</span> === cur.<span class="hljs-property">val</span>) &#123;<br>            count++<br>            cur = cur.<span class="hljs-property">next</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>) &#123;<br>            p.<span class="hljs-property">next</span> = cur.<span class="hljs-property">next</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p = cur<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummyHead.<span class="hljs-property">next</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>中间件模式</title>
    <url>/posts/ee084ea8.html</url>
    <content><![CDATA[<h2 id="【译】中间件模式Mediator-Middleware-Pattern"><a href="#【译】中间件模式Mediator-Middleware-Pattern" class="headerlink" title="【译】中间件模式Mediator&#x2F;Middleware Pattern"></a>【译】中间件模式<a href="https://www.patterns.dev/vanilla/mediator-pattern">Mediator&#x2F;Middleware Pattern</a></h2><p><img src="/pic/mul-com.png" alt="many-part"> <img src="/pic/single-store.png" alt="single-mediator"></p>
<p>中介者模式使组件能够通过一个中心点（中介者）相互交互。组件不直接相互通信，而是将请求发送给中介者，由中介者进行转发！在JavaScript中，中介者通常只是一个对象字面量或一个函数。</p>
<p>您可以将这种模式与空中交通管制员和飞行员之间的关系进行比较。飞行员不直接相互交流，这可能会导致混乱，而是与空中交通管制员交流。空中交通管制员确保所有飞机都获得它们需要的信息，以确保安全飞行，避免与其他飞机相撞。</p>
<p>虽然我们希望不会在JavaScript中控制飞机，但我们经常需要处理对象之间的多向数据。如果组件数量很大，组件之间的通信可能会变得相当混乱。</p>
<p>与让每个对象直接相互通信，导致多对多的关系不同，对象的请求由中介者处理。中介者处理这个请求，并将其发送到需要的位置。</p>
<p>中介者模式的一个很好的应用案例是聊天室！聊天室中的用户不会直接相互交流。相反，聊天室充当用户之间的中介者。</p>
<p>我们可以创建连接到聊天室的新用户。每个用户实例都有一个send方法，我们可以使用它来发送消息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatRoom</span> &#123;<br>  <span class="hljs-title function_">logMessage</span>(<span class="hljs-params">user, message</span>) &#123;<br>    <span class="hljs-keyword">const</span> sender = user.<span class="hljs-title function_">getName</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleString()&#125;</span> [<span class="hljs-subst">$&#123;sender&#125;</span>]: <span class="hljs-subst">$&#123;message&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, chatroom</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">chatroom</span> = chatroom;<br>  &#125;<br><br>  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">send</span>(<span class="hljs-params">message</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">chatroom</span>.<span class="hljs-title function_">logMessage</span>(<span class="hljs-variable language_">this</span>, message);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> chatroom = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatRoom</span>();<br><br><span class="hljs-keyword">const</span> user1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;John Doe&quot;</span>, chatroom);<br><span class="hljs-keyword">const</span> user2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Jane Doe&quot;</span>, chatroom);<br><br>user1.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;Hi there!&quot;</span>);<br>user2.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;Hey!&quot;</span>);<br><br></code></pre></td></tr></table></figure>

<h3 id="案例研究"><a href="#案例研究" class="headerlink" title="案例研究"></a>案例研究</h3><p>Express.js是一个流行的Web应用程序服务器框架。我们可以为用户访问的特定路由添加回调函数。</p>
<p>假设我们想在用户访问根路径’&#x2F;‘时向请求添加一个头部。我们可以在一个中间件回调函数中添加这个头部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>)();<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  req.<span class="hljs-property">headers</span>[<span class="hljs-string">&quot;test-header&quot;</span>] = <span class="hljs-number">1234</span>;<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>next方法调用请求-响应周期中的下一个回调函数。我们实际上正在创建一个中间件函数链，它位于请求和响应之间.</p>
<p>让我们添加另一个中间件函数，检查是否正确添加了test-header。前一个中间件函数添加的更改将在整个链中可见。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>)();<br><br>app.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-string">&quot;/&quot;</span>,<br>  <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>    req.<span class="hljs-property">headers</span>[<span class="hljs-string">&quot;test-header&quot;</span>] = <span class="hljs-number">1234</span>;<br>    <span class="hljs-title function_">next</span>();<br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Request has test header: <span class="hljs-subst">$&#123;!!req.headers[<span class="hljs-string">&quot;test-header&quot;</span>]&#125;</span>`</span>);<br>    <span class="hljs-title function_">next</span>();<br>  &#125;<br>);<br></code></pre></td></tr></table></figure>

<p>完美！我们可以通过一个或多个中间件函数跟踪和修改请求对象，直到响应为止。</p>
<p>每当用户访问根端点’&#x2F;‘时，这两个中间件回调函数将被调用。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>中间件模式使我们能够通过让所有通信流经一个中心点来简化对象之间的多对多关系。</p>
]]></content>
      <categories>
        <category>Patterns</category>
      </categories>
  </entry>
  <entry>
    <title>nodejs内存问题排查</title>
    <url>/posts/c1f90a33.html</url>
    <content><![CDATA[<h3 id="监控采集"><a href="#监控采集" class="headerlink" title="监控采集"></a>监控采集</h3><h4 id="event-loop-delay"><a href="#event-loop-delay" class="headerlink" title="event loop delay"></a>event loop delay</h4><p>在 Node.js 中，事件循环是一个无限循环，它会不断地检查是否有新的事件需要处理。如果有，它就会取出事件并执行相应的回调函数。然后，它会再次检查是否有新的事件需要处理。这个过程会一直重复，直到没有新的事件需要处理。</p>
<p>Node.js 的 Event Loop Delay 是指事件循环在处理和执行任务时的延迟时间。这个延迟时间是由于事件循环在处理一些长时间运行的任务时，无法立即处理新的事件或任务，从而导致的延迟。</p>
<blockquote>
<p>同步代码执行时间很长，CPU 密集型任务，可以通过子进程(child_process)或者多进程(cluster)进行优化</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello, World!&quot;</span> &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Server is running on port <span class="hljs-subst">$&#123;port&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-keyword">let</span> stashDelays = [];<br><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> maxDelay = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...stashDelays);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`max event loop delay per second: <span class="hljs-subst">$&#123;maxDelay&#125;</span>ms`</span>);<br>  stashDelays = [];<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">now</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> ts = process.<span class="hljs-title function_">hrtime</span>();<br>  <span class="hljs-keyword">return</span> ts[<span class="hljs-number">0</span>] * <span class="hljs-number">1e3</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(ts[<span class="hljs-number">1</span>] / <span class="hljs-number">1e6</span>); <span class="hljs-comment">// ms</span><br>&#125;<br><br><span class="hljs-keyword">let</span> prev = <span class="hljs-title function_">now</span>();<br><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> current = <span class="hljs-title function_">now</span>();<br>  <span class="hljs-keyword">const</span> delay = current - prev - <span class="hljs-number">10</span>;<br>  prev = current;<br>  stashDelays.<span class="hljs-title function_">push</span>(delay);<br>&#125;, <span class="hljs-number">10</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 模拟阻塞时间循环</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">num</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>, sqrt = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(num); i &lt;= sqrt; i++) &#123;<br>      <span class="hljs-keyword">if</span> (num % i === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> num &gt; <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">generatePrimeNumbers</span>(<span class="hljs-params">limit</span>) &#123;<br>    <span class="hljs-keyword">const</span> primes = [];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num = <span class="hljs-number">2</span>; primes.<span class="hljs-property">length</span> &lt; limit; num++) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPrime</span>(num)) &#123;<br>        primes.<span class="hljs-title function_">push</span>(num);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> primes;<br>  &#125;<br><br>  <span class="hljs-title function_">generatePrimeNumbers</span>(<span class="hljs-number">100000</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>

<h4 id="active-handles"><a href="#active-handles" class="headerlink" title="active handles"></a>active handles</h4><p>active handles（活动句柄）是 Node.js 事件循环中的一种概念，用于表示当前正在活动中的异步操作。它们可以是网络套接字、文件描述符、定时器或其他类型的异步操作。</p>
<p>在 Node.js 的事件循环中，当一个异步操作被触发时，它会创建一个活动句柄，并将其添加到事件循环中。活动句柄会监听异步操作的完成状态，并在操作完成后触发相应的回调函数。</p>
<p>活动句柄的存在使得 Node.js 能够同时处理多个异步操作，而不需要阻塞或等待每个操作的完成。它们允许 Node.js 在等待某些操作完成的同时，继续处理其他任务，提高了应用程序的并发性能和响应能力。</p>
<p>活动句柄的用途包括但不限于：</p>
<ul>
<li><p>网络通信：活动句柄可以用于处理网络套接字的读写操作，实现高性能的网络通信。</p>
</li>
<li><p>文件操作：活动句柄可以用于处理文件的读写操作，实现异步的文件操作。</p>
</li>
<li><p>定时器：活动句柄可以用于处理定时器的触发和回调函数的执行，实现定时任务和延迟操作。</p>
</li>
<li><p>进程间通信：活动句柄可以用于处理进程间通信的管道或消息队列，实现异步的进程间通信。</p>
</li>
<li><p>其他异步操作：活动句柄还可以用于处理其他类型的异步操作，例如数据库查询、HTTP 请求等。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">var</span> wtf = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;wtfnode&quot;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello, World!&quot;</span> &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Server is running on port <span class="hljs-subst">$&#123;port&#125;</span>`</span>);<br>&#125;);<br><br>wtf.<span class="hljs-title function_">init</span>();<br>wtf.<span class="hljs-title function_">setLogger</span>(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-function">(<span class="hljs-params">message, ...optionalParams</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;info: &quot;</span>, message, ...optionalParams);<br>&#125;);<br>wtf.<span class="hljs-title function_">setLogger</span>(<span class="hljs-string">&quot;warn&quot;</span>, <span class="hljs-function">(<span class="hljs-params">message, ...optionalParams</span>) =&gt;</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(message, ...optionalParams)<br>);<br>wtf.<span class="hljs-title function_">setLogger</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">message, ...optionalParams</span>) =&gt;</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(message, ...optionalParams)<br>);<br><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  wtf.<span class="hljs-title function_">dump</span>();<br>&#125;, <span class="hljs-number">1000</span>).<span class="hljs-title function_">unref</span>();<br><br></code></pre></td></tr></table></figure>

<h4 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h4><p>process.memoryUsage()是Node.js中的一个方法，用于获取当前进程的内存使用情况。它返回一个包含不同内存指标的对象，用于监视和分析应用程序的内存消耗。</p>
<p>process.memoryUsage()方法返回的对象包含以下属性：</p>
<ul>
<li>rss（Resident Set Size）：表示进程占用的内存大小。</li>
<li>heapTotal：表示V8引擎分配的堆内存总量。</li>
<li>heapUsed：表示V8引擎当前使用的堆内存量。</li>
<li>external：表示V8引擎管理的外部内存量，如C++绑定和缓冲区对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">formatBytes</span> = (<span class="hljs-params">bytes</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (bytes === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0B&quot;</span>;<br>  <span class="hljs-keyword">const</span> unit = <span class="hljs-number">1024</span>;<br>  <span class="hljs-keyword">const</span> decimals = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">const</span> sizes = [<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;KB&quot;</span>, <span class="hljs-string">&quot;MB&quot;</span>, <span class="hljs-string">&quot;GB&quot;</span>, <span class="hljs-string">&quot;TB&quot;</span>, <span class="hljs-string">&quot;PB&quot;</span>];<br>  <span class="hljs-keyword">const</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(bytes) / <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(unit));<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="hljs-built_in">parseFloat</span>(<span class="hljs-title class_">String</span>(bytes / <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(unit, i))).<span class="hljs-title function_">toFixed</span>(decimals) +<br>    sizes[i] +<br>    <span class="hljs-string">&quot;&quot;</span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">logMem</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> mem = process.<span class="hljs-title function_">memoryUsage</span>();<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">arrayBuffers</span>: <span class="hljs-title function_">formatBytes</span>(mem.<span class="hljs-property">arrayBuffers</span>),<br>    <span class="hljs-attr">external</span>: <span class="hljs-title function_">formatBytes</span>(mem.<span class="hljs-property">external</span>),<br>    <span class="hljs-attr">heapTotal</span>: <span class="hljs-title function_">formatBytes</span>(mem.<span class="hljs-property">heapTotal</span>),<br>    <span class="hljs-attr">heapUsed</span>: <span class="hljs-title function_">formatBytes</span>(mem.<span class="hljs-property">heapUsed</span>),<br>    <span class="hljs-attr">rss</span>: <span class="hljs-title function_">formatBytes</span>(mem.<span class="hljs-property">rss</span>),<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="日志采集"><a href="#日志采集" class="headerlink" title="日志采集"></a>日志采集</h3><p>AsyncLocalStorage是Node.js的一个模块，用于在异步操作中存储和共享上下文数据。它提供了一种简单的方式来跟踪和传递上下文数据，以便在异步操作中访问和使用。</p>
<p>在传统的Node.js应用程序中，上下文数据通常是通过回调函数参数或全局变量来传递的。然而，这种方式在复杂的异步操作链中会变得非常繁琐和容易出错。</p>
<p>AsyncLocalStorage模块通过使用async_hooks模块来实现上下文数据的跟踪和传递。它提供了以下主要功能：</p>
<ol>
<li><p>存储上下文数据：使用AsyncLocalStorage的run方法，可以将上下文数据存储在当前执行上下文中。这样，无论在哪个异步操作中，都可以通过AsyncLocalStorage来访问和使用这些数据。</p>
</li>
<li><p>共享上下文数据：AsyncLocalStorage的上下文数据是线程安全的，可以在异步操作链中共享。这意味着在异步操作中创建的新的上下文数据可以在后续的异步操作中访问和使用。</p>
</li>
<li><p>异步操作链中的上下文传递：在异步操作链中，AsyncLocalStorage会自动将上下文数据传递给下一个异步操作。这样，你无需手动传递上下文数据，而是可以在任何异步操作中直接访问它们。</p>
</li>
</ol>
<p>AsyncLocalStorage模块在处理异步操作时非常有用，特别是在处理请求-响应周期中的上下文数据时，适合追踪异步过程。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AsyncLocalStorage</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;async_hooks&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> storage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncLocalStorage</span>&lt;any&gt;();<br><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Injectable</span>, <span class="hljs-title class_">NestMiddleware</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Request</span>, <span class="hljs-title class_">Response</span>, <span class="hljs-title class_">NextFunction</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span>;<br><br>@<span class="hljs-title class_">Injectable</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerMiddleware</span> implements <span class="hljs-title class_">NestMiddleware</span> &#123;<br>  <span class="hljs-title function_">use</span>(<span class="hljs-params">req: Request, res: Response, next: NextFunction</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Request: <span class="hljs-subst">$&#123;req.method&#125;</span> <span class="hljs-subst">$&#123;req.url&#125;</span>`</span>);<br>    storage.<span class="hljs-title function_">run</span>(<br>        &#123;<br>          <span class="hljs-attr">traceId</span>: <span class="hljs-title function_">uuidv4</span>(),<br>        &#125;,<br>        <span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-title function_">next</span>()<br>        &#125;<br>    )<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h3><ol>
<li>安装 Autocannon：在终端中运行以下命令来全局安装 Autocannon：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm install -g autocannon<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><p>运行 Autocannon：在终端中运行以下命令来使用 Autocannon 进行压力测试：<br><code>autocannon -c &lt;connections&gt; -d &lt;duration&gt; -m &lt;method&gt; &lt;url&gt;</code><br>其中，<code>&lt;connections&gt;</code>是并发连接数，<code>&lt;duration&gt;</code>是测试持续时间（以秒为单位），<code>&lt;method&gt;</code>是请求方法 GET、POST、PUT、DELETE，<code>&lt;url&gt;</code>是要测试的 URL。</p>
</li>
<li><p>查看测试结果：Autocannon 会在测试结束后提供有关请求响应时间(Latency)、吞吐量 QPS(Req&#x2F;Sec)和每秒传输量 BPS(Bytes&#x2F;Sec)等指标的实时报告。您可以查看报告中的 Latency、Req&#x2F;Sec 和 Bytes&#x2F;Sec 等字段来评估服务器的性能和稳定性。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">autocannon -p &#x27;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30&#125;&#x27; -H &quot;Content-Type: application/json&quot; -m POST http://localhost:3000/api/users<br></code></pre></td></tr></table></figure>

<p><img src="/pic/autocannon.png" alt="autocannon"></p>
<h3 id="缓慢的内存泄露"><a href="#缓慢的内存泄露" class="headerlink" title="缓慢的内存泄露"></a>缓慢的内存泄露</h3><p>观察内存图表，如果发现内存逐步上升没有下降，很可能存在内存泄露。</p>
<p>首先要确定是应用nodejs进程占用的内存过多，还是应用里启动了第三方库的服务占用了大量内存。上面收集当前进程的memory指标就派上了用场。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express&quot;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/api/hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>(); <span class="hljs-comment">// client start a server</span><br>  res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello, World!&quot;</span> &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Server is running on port <span class="hljs-subst">$&#123;port&#125;</span>`</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure>

<p>由于每次请求就new一个client实例，实例的背后会启动一个本地server，server也许还会持续发送心跳上报。这种内存泄露往往伴随着网络IO居高不下。</p>
<p>大部分的内存泄露发生在自身应用程序进程。可以提取heapdump进行分析。</p>
<ul>
<li>提取heapdump</li>
<li>chrome devtools分析</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> heapdump = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;heapdump&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/extract-heapdump&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> filename = <span class="hljs-string">`heapdump-<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>.heapsnapshot`</span>;<br>  <br>  <span class="hljs-comment">// 提取heapdump文件</span><br>  heapdump.<span class="hljs-title function_">writeSnapshot</span>(filename, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to extract heapdump:&#x27;</span>, err);<br>      res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Failed to extract heapdump&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Heapdump extracted:&#x27;</span>, filename);<br>      res.<span class="hljs-title function_">download</span>(filename, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">// 删除临时的heapdump文件</span><br>        fs.<span class="hljs-title function_">unlink</span>(filename, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to delete heapdump file:&#x27;</span>, err);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Heapdump file deleted:&#x27;</span>, filename);<br>          &#125;<br>        &#125;);<br>      &#125;);<br>    &#125;<br>  &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server started on port 3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>使用<code>node-oom-heapdump</code>库，在oom时自动heap dump, 然后使用chrome devtools分析。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 瞬间oom</span><br><span class="hljs-keyword">let</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-keyword">let</span> oom = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;node-oom-heapdump&quot;</span>)(&#123;<br>    <span class="hljs-attr">heapdumpOnOOM</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">//OOMImplementation: &quot;GC_MONITORING&quot;, // use the old implementation</span><br>    <span class="hljs-attr">addTimestamp</span>: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-comment">// 设置一个定时器，在一定时间间隔后触发OOM</span><br><span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 模拟内存泄漏，例如创建一个大数组</span><br>  <span class="hljs-keyword">const</span> largeArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&quot;a&quot;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">1000</span>));<br>&#125;, <span class="hljs-number">1000</span>);<br><br><br><span class="hljs-comment">// node --max_old_space_size=40 --optimize_for_size a.js</span><br><br></code></pre></td></tr></table></figure>
<p><img src="/pic/chrome-dev.png" alt="chrome devtools"></p>
<h3 id="被操作系统-kill"><a href="#被操作系统-kill" class="headerlink" title="被操作系统 kill"></a>被操作系统 kill</h3><p>external的分配超出物理内存上限，操作系统会将nodejs进程kill掉。</p>
<blockquote>
<p>例如：由于计算bug，传给typeorm的查询条件为空，导致查询了整张数据表回来。</p>
</blockquote>
<p>这种情况下，没有机会导出heap dump, core dump。日志也就是最有效的手段了。日志在任何情况下都能够提供线索。</p>
<p>在应用程序AOP统一加拦截器，打印日志，打印开始和结束。如果出现了开始，没有结束，说明这部分接口里存在引发问题的接口。</p>
<p>进一步细分筛查，过滤一台机器的日志，将not end的接口最后一条日志过滤出来。</p>
<p>根据日志最后停顿的位置，排查附近代码，一般是停在一个读IO操作(查询数据库，下载文件等)前一步，code review可以基本找到问题。</p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>可视化V8引擎中的内存管理</title>
    <url>/posts/695a0b8f.html</url>
    <content><![CDATA[<h2 id="【译】可视化V8引擎中的内存管理Visualizing-memory-management-in-V8-Engine-JavaScript-NodeJS-Deno-WebAssembly"><a href="#【译】可视化V8引擎中的内存管理Visualizing-memory-management-in-V8-Engine-JavaScript-NodeJS-Deno-WebAssembly" class="headerlink" title="【译】可视化V8引擎中的内存管理Visualizing memory management in V8 Engine (JavaScript, NodeJS, Deno, WebAssembly)"></a>【译】可视化V8引擎中的内存管理<a href="https://deepu.tech/memory-management-in-v8/">Visualizing memory management in V8 Engine (JavaScript, NodeJS, Deno, WebAssembly)</a></h2><h2 id="V8内存结构"><a href="#V8内存结构" class="headerlink" title="V8内存结构"></a>V8内存结构</h2><p>首先，让我们来看一下V8引擎的内存结构是什么。由于JavaScript是单线程的，V8也为每个JavaScript上下文使用一个单独的进程，因此如果你使用服务工作线程，它将为每个工作线程启动一个新的V8进程。运行中的程序总是由V8进程中分配的某些内存来表示，这被称为常驻集（Resident Set）。这进一步被划分为以下不同的段：<br><img src="/pic/v8-mem.png" alt="v8-mem"></p>
<p>这与我们在前一章中看到的JVM内存结构有些相似。让我们看看这些不同段的用途是什么：</p>
<h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p>Heap是 V8存储对象和动态数据的地方。它是有一大块内存空间组成，它也是Garbage Collection工作的地方。</p>
<ul>
<li><p>New Space(新生代): 它是生命周期较短的对象存储的地方。它是通过Scavenger(Minor GC)算法进行管理。</p>
</li>
<li><p>Old Space(老生代): 当在 New Space保存的数据经过两次Scavenger(Minor GC)循环后还在未被清除，则会被移到此处。这里的管理内存算法是 Major GC(Mark-Sweep &amp; Mark-Compact)。</p>
<ul>
<li>Old pointer space - 包含具有指向其他对象的指针的幸存对象。</li>
<li>Old data space - 包含仅包含数据的对象（没有指向其他对象的指针）。</li>
</ul>
</li>
<li><p>Large object space(老生代): 这里是那些大于其他空间大小限制的对象所存在的地方。每个对象都会获得自己的mmap内存区域。Large Object Space 属于老生代，管理内存算法是 Major GC(Mark-Sweep &amp; Mark-Compact)。</p>
</li>
<li><p>Code space(老生代): 存储着 Just In Time(JIT)编译后的代码块。这是唯一具有可执行内存的空间。</p>
</li>
<li><p>Cell space, property cell space, and map space： 这些区域存放Cell、属性Cell和Map，每个区域因为都是存放相同大小的元素，因此内存结构很简单。</p>
</li>
</ul>
<p>这些空间中的每一个都是由一组页面（pages）组成的。页面是从操作系统通过mmap分配的连续内存块。除了大对象空间（Large object space）之外，每个页面的大小都是1MB。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>这是栈内存区域，每个V8进程都有一个栈。这里是存储静态数据的地方，包括方法&#x2F;函数帧、原始值和指向对象的指针。栈内存限制可以使用V8的<code>--stack_size</code>标志来设置。</p>
<h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>Node.js 堆外内存（External Memory）提供了一种机制，允许JavaScript代码直接与非V8管理的内存空间交互，这通常用于处理大型二进制数据，如图像、音频、视频或其他大型数据集。使用堆外内存可以提高性能，原因如下：</p>
<ul>
<li><p>避免V8垃圾回收的影响：V8的垃圾回收机制主要针对堆内存进行管理，当内存使用量达到一定阈值时，会触发垃圾回收过程。这个过程可能会导致应用程序的暂停或性能下降。而堆外内存不受V8垃圾回收的直接影响，可以减少因垃圾回收引起的性能波动。</p>
</li>
<li><p>减少内存复制：在处理大型数据时，如果使用V8堆内存，那么在数据传输过程中可能会涉及到多次内存复制操作，这会增加CPU的使用率并降低性能。而堆外内存允许数据直接在用户空间和内核空间之间传输，减少了内存复制的开销，从而提高数据处理效率。</p>
</li>
<li><p>提高缓存效率：对于需要频繁访问的大量数据，使用堆外内存可以提高缓存的效率。因为堆外内存不受V8堆内存大小限制的约束，可以分配更大的连续内存空间，这对于缓存大型数据集特别有用。</p>
</li>
<li><p>避免内存碎片化：V8堆内存在使用过程中可能会产生内存碎片，这会影响内存分配的效率。而堆外内存可以通过操作系统的虚拟内存系统来管理，可以更好地处理内存碎片化问题。</p>
</li>
<li><p>跨进程共享内存：在某些情况下，堆外内存可以在不同的进程之间共享，这对于需要跨进程通信的应用程序来说是一个优势，因为它减少了数据在进程间传输的开销。</p>
</li>
</ul>
<p>以下是一个示例代码，展示如何使用Buffer来处理大型二进制数据，这种方式通常比使用JavaScript字符串更高效，因为字符串在V8堆内分配，并且可能会因为字符编码转换而消耗更多资源。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">const</span> v8 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;v8&quot;</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">formatBytes</span> = (<span class="hljs-params">bytes</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (bytes === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0B&quot;</span>;<br>  <span class="hljs-keyword">const</span> unit = <span class="hljs-number">1024</span>;<br>  <span class="hljs-keyword">const</span> decimals = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">const</span> sizes = [<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;KB&quot;</span>, <span class="hljs-string">&quot;MB&quot;</span>, <span class="hljs-string">&quot;GB&quot;</span>, <span class="hljs-string">&quot;TB&quot;</span>, <span class="hljs-string">&quot;PB&quot;</span>];<br>  <span class="hljs-keyword">const</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(bytes) / <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(unit));<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="hljs-built_in">parseFloat</span>(<span class="hljs-title class_">String</span>(bytes / <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(unit, i))).<span class="hljs-title function_">toFixed</span>(decimals) +<br>    sizes[i] +<br>    <span class="hljs-string">&quot;&quot;</span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">logMem</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> mem = process.<span class="hljs-title function_">memoryUsage</span>();<br>  <span class="hljs-keyword">const</span> heap = v8.<span class="hljs-title function_">getHeapStatistics</span>();<br>  <span class="hljs-comment">// const heapSpace = v8.getHeapSpaceStatistics();</span><br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">mem</span>: &#123;<br>      <span class="hljs-attr">arrayBuffers</span>: <span class="hljs-title function_">formatBytes</span>(mem.<span class="hljs-property">arrayBuffers</span>),<br>      <span class="hljs-attr">external</span>: <span class="hljs-title function_">formatBytes</span>(mem.<span class="hljs-property">external</span>),<br>      <span class="hljs-attr">heapTotal</span>: <span class="hljs-title function_">formatBytes</span>(mem.<span class="hljs-property">heapTotal</span>),<br>      <span class="hljs-attr">heapUsed</span>: <span class="hljs-title function_">formatBytes</span>(mem.<span class="hljs-property">heapUsed</span>),<br>      <span class="hljs-attr">rss</span>: <span class="hljs-title function_">formatBytes</span>(mem.<span class="hljs-property">rss</span>),<br>    &#125;,<br>    <span class="hljs-attr">heap</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(heap).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">[k, v]</span>) =&gt;</span> [k, <span class="hljs-title function_">formatBytes</span>(v)])<br>    ),<br>  &#125;;<br>&#125;;<br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doTask</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;./large-file.json&quot;</span>);<br>  <span class="hljs-keyword">return</span> content.<span class="hljs-title function_">toString</span>()<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 获取堆内存统计信息</span><br>  <span class="hljs-keyword">let</span> memStatistics = <span class="hljs-title function_">logMem</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;before reading file:&quot;</span>, memStatistics);<br><br>  <span class="hljs-keyword">const</span> str = <span class="hljs-title function_">doTask</span>()<br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> memStatistics = <span class="hljs-title function_">logMem</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;after reading file:&quot;</span>, str.<span class="hljs-property">length</span>, memStatistics);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="为什么40M文件读取为字符串后占用80M内存？"><a href="#为什么40M文件读取为字符串后占用80M内存？" class="headerlink" title="为什么40M文件读取为字符串后占用80M内存？"></a>为什么40M文件读取为字符串后占用80M内存？</h4><p>buffer占用了40M, 字符串占用了40M。heap 释放，会立即释放回操作系统。external释放，但不会归还操作系统，rss不会很快释放，实际上是可以重用的。</p>
<p>rss &#x3D;&gt; +40M（buffer）+40M（string） &#x3D;&gt;  -40M（string）&#x3D;&gt; …long time &#x3D;&gt; -40M（buffer）<br>heapUsed和external指标，在GC后会立即缩小。rss指标，external已分配的部分会保留一段时间。</p>
<h4 id="为什么buffer释放了，但是rss看起来没有释放？"><a href="#为什么buffer释放了，但是rss看起来没有释放？" class="headerlink" title="为什么buffer释放了，但是rss看起来没有释放？"></a>为什么buffer释放了，但是rss看起来没有释放？</h4><p>当一个Buffer对象被回收后，Node.js的内存管理机制并不会立即将其占用的内存释放回操作系统。这是因为Node.js使用了一种称为”slab allocator”的内存管理机制，它会将内存分配给Buffer对象并保留一段时间，以便在未来的内存分配中能够更高效地使用。</p>
<p>具体来说，当一个Buffer对象被回收后，它的内存会被标记为可重用，而不是立即返回给操作系统。这样做的目的是为了避免频繁的内存分配和释放操作，从而提高性能。当下次需要分配Buffer对象时，Node.js会尝试重用之前已经分配的内存，而不是再次向操作系统请求新的内存。</p>
<p>因此，即使一个Buffer对象被回收，RSS（Resident Set Size，进程在物理内存中的占用）可能不会立即缩小。只有当Node.js认为有必要重新分配内存时，才会将之前回收的内存返回给操作系统。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 获取堆内存统计信息</span><br>  <span class="hljs-keyword">const</span> memStatistics = <span class="hljs-title function_">logMem</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;before reading file:&quot;</span>, memStatistics);<br><br>  <span class="hljs-comment">// 读取文件</span><br>  <span class="hljs-keyword">let</span> content1 = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;./large-file.json&quot;</span>);<br>  <span class="hljs-keyword">let</span> content2 = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;./large-file.json&quot;</span>);<br>  <span class="hljs-keyword">let</span> content3 = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;./large-file.json&quot;</span>);<br>  <span class="hljs-keyword">let</span> content4 = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;./large-file.json&quot;</span>);<br><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> content5 = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;./large-file.json&quot;</span>); <span class="hljs-comment">// rss没有再增长，复用了buffer</span><br>  &#125;, <span class="hljs-number">60000</span>)<br>  <span class="hljs-variable language_">global</span>.<span class="hljs-title function_">gc</span>();<br>&#125;<br><br><span class="hljs-title function_">main</span>();<br><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> memStatistics = <span class="hljs-title function_">logMem</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;after reading file:&quot;</span>, memStatistics);<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="V8内存管理：垃圾回收"><a href="#V8内存管理：垃圾回收" class="headerlink" title="V8内存管理：垃圾回收"></a>V8内存管理：垃圾回收</h3><p>现在我们知道了V8是如何分配内存的，让我们看看它如何自动管理对应用程序性能至关重要的堆内存。当程序尝试在堆上分配的内存超过可用的自由内存时（这取决于设置的V8标志），我们会遇到内存不足的错误。如果管理不当，堆还可能导致内存泄漏。</p>
<p>V8通过垃圾回收来管理堆内存。简单来说，它释放孤立对象使用的内存，即不再直接或间接（通过另一个对象中的引用）从栈引用的对象，以便为新对象的创建腾出空间。</p>
<blockquote>
<p>奥里诺科（Orinoco）是V8垃圾回收项目的代号，该项目旨在利用并行、增量和并发技术进行垃圾回收，以释放主线程。</p>
</blockquote>
<p>V8中的垃圾回收器负责回收未使用的内存，以便V8进程重用。</p>
<p>V8的垃圾回收器是分代的（根据对象在堆中的年龄将对象分组，并在不同的阶段进行清理）。V8使用两个阶段和三种不同的算法进行垃圾回收：</p>
<h3 id="Minor-GC-Scavenger"><a href="#Minor-GC-Scavenger" class="headerlink" title="Minor GC (Scavenger)"></a>Minor GC (Scavenger)</h3><p>这种类型的垃圾回收保持年轻代或新生代空间紧凑且干净。对象在新生代中分配，这个空间相当小（根据行为启发式算法在1到8MB之间）。在“新生代”中分配内存非常便宜：有一个分配指针，我们在想要为新对象保留空间时就会递增它。当分配指针到达新生代的末尾时，就会触发一次小型垃圾回收（minor GC）。这个过程也称为Scanvenger，它实现了Cheney算法。它频繁发生，并使用并行辅助线程，速度非常快。</p>
<p>让我们来看一下小型垃圾回收过程：</p>
<p>新生代被划分为两个大小相等的半空间：to-space和from-space。大多数分配都在from-space进行（除了某些类型的对象，例如可执行代码，它们总是在老生代中分配）。当from-space填满时，触发小型垃圾回收。</p>
<ul>
<li><p>标记：从根对象开始，递归扫描所有可达对象。所有可达的对象都被标记为活跃的。</p>
</li>
<li><p>复制：将所有活跃对象从From-Space复制到To-Space，同时更新所有指向这些对象的引用。</p>
</li>
<li><p>清理：完成复制后，From-Space中剩下的都是不可达的对象，即垃圾，这些垃圾将被清除。</p>
</li>
<li><p>角色互换：复制和清理完成后，From-Space和To-Space的角色互换，新的From-Space用于存放新创建的对象，而原来的From-Space（现在的To-Space）用于下一次垃圾回收时存放复制的对象。</p>
</li>
</ul>
<p><img src="/pic/minor-gc.svg" alt="minor-gc 来源: https://v8.dev/blog/trash-talk"></p>
<p>因此，我们看到了小型垃圾回收（Minor GC）是如何从年轻代（young generation）回收空间并保持其紧凑的。这是一个停止世界（stop-the-world）的过程，但它非常快速和高效，以至于大多数时间里可以忽略不计。由于这个过程不会扫描“老空间”（old space）中的对象以查找对“新空间”（new space）的任何引用，因此它使用了一个记录所有从老空间指向新空间的指针的寄存器。这是通过一种称为写屏障（write barriers）的过程记录到存储缓冲区（store buffer）中的。</p>
<h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>这种垃圾回收（GC）方式能够保持老年代（old generation）空间的紧凑和清洁。当V8引擎根据动态计算的限制判断老空间不足时，会在小型垃圾回收（minor GC）周期中填满后触发。</p>
<p>Scavenger算法非常适合小数据量的垃圾回收，但对于大型堆（heap）来说却不切实际，因为老空间存在内存开销，因此主要的垃圾回收（major GC）采用的是标记-清除-压缩（Mark-Sweep-Compact）算法。该算法使用三色（白色-灰色-黑色）标记系统。因此，主要的垃圾回收是一个三步骤的过程，而第三步骤的执行则取决于一个碎片化启发式算法。</p>
<p>具体来说，标记-清除-压缩算法的工作流程如下：</p>
<ul>
<li><p>标记（Marking）：这是两种算法共有的第一步，垃圾回收器在这一阶段识别出哪些对象正在被使用，以及哪些对象没有被使用。从垃圾回收（GC）根（如栈指针）开始，递归地标记所有可达的对象为存活状态。从技术角度来看，这是一个对堆进行的深度优先搜索（depth-first-search），堆可以被视为一个有向图。</p>
</li>
<li><p>清除（Sweeping）：垃圾回收器遍历堆，并记录所有未被标记为存活的对象的内存地址。这些空间现在在空闲列表（free list）中被标记为空闲，并且可以用来存储其他对象。</p>
</li>
<li><p>压缩（Compacting）：在清除之后，如果需要，所有存活的对象将被移动到一起。这将减少内存碎片化，并提高将内存分配给新对象的性能。</p>
</li>
</ul>
<p><img src="/pic/major-gc.gif" alt="major gc"></p>
<p>这种垃圾回收（GC）也被称为“停止世界”（stop-the-world）垃圾回收，因为在执行垃圾回收过程中它们会引入暂停时间。为了避免这种情况，V8引擎采用了一些技术，例如：</p>
<p><img src="/pic/concurrent-gc.svg" alt="concurrent-gc"></p>
<ul>
<li><p>增量垃圾回收（Incremental GC）：垃圾回收不是一次性完成，而是分多个增量步骤进行。</p>
</li>
<li><p>并发标记（Concurrent marking）：使用多个辅助线程并发地进行标记，这样做不会影响主JavaScript线程。同时，使用写屏障来跟踪JavaScript在辅助线程并发标记时创建的对象之间的新引用。</p>
</li>
<li><p>并发清除&#x2F;压缩（Concurrent sweeping&#x2F;compacting）：清除和压缩工作也是在辅助线程中并发进行的，这样做不会影响主JavaScript线程。</p>
</li>
<li><p>延迟清除（Lazy sweeping）：延迟清除涉及将垃圾页面的删除工作推迟到内存需要时才进行。</p>
</li>
</ul>
<p>让我们来审视一下主要的垃圾回收（Major GC）过程：</p>
<ol>
<li><p>假设已经经历了许多次小型垃圾回收（minor GC）周期，老年代（old space）几乎已满，V8决定触发一次“主要垃圾回收”（Major GC）。</p>
</li>
<li><p>主要垃圾回收从栈指针开始，递归遍历对象图，标记那些被使用的存活对象（Used memory），以及在老年代中剩余的对象作为垃圾（Orphans）。这一过程使用多个并发的辅助线程来完成，每个辅助线程都跟随一个指针进行标记。这不会对主JavaScript线程产生影响。</p>
</li>
<li><p>当并发标记完成，或者达到内存限制时，垃圾回收会使用主线程进行标记的最终步骤（mark finalization）。这会导致一个短暂的暂停时间。</p>
</li>
<li><p>主要垃圾回收现在使用并发清除线程标记所有孤立对象的内存为空闲。同时也会触发并行压缩任务，将相关的记忆块移动到同一页以避免碎片化。在这些步骤中，指针会被更新。</p>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文应该为您提供了V8内存结构和内存管理的概览。这不是详尽无遗的，还有许多更高级的概念，您可以从v8.dev网站上学习到它们。但对于大多数JavaScript&#x2F; WebAssembly开发者来说，这一层次的信息已经足够了，我希望这能帮助您编写更好的代码，考虑到这些因素，以实现更高效的应用程序，同时牢记这些知识将有助于您避免可能遇到的下一个内存泄漏问题。</p>
<p>希望您在了解V8内部机制的过程中有所收获，敬请期待本系列的下一篇文章。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://developer.aliyun.com/article/592880">解读 V8 GC Log（二）: 堆内外内存的划分与 GC 算法</a></p>
<p><a href="https://deepu.tech/memory-management-in-v8/">Visualizing memory management in V8 Engine (JavaScript, NodeJS, Deno, WebAssembly)</a></p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>提供者模式</title>
    <url>/posts/bd91c8c4.html</url>
    <content><![CDATA[<h2 id="【译】提供者模式Provider-Pattern"><a href="#【译】提供者模式Provider-Pattern" class="headerlink" title="【译】提供者模式Provider Pattern"></a>【译】提供者模式<a href="https://www.patterns.dev/vanilla/provider-pattern">Provider Pattern</a></h2><p>在某些情况下，我们希望将数据提供给应用程序中的许多（也许是全部）组件。虽然我们可以使用props将数据传递给组件，但如果几乎所有组件都需要访问props的值，这可能很难做到。</p>
<p>我们经常会遇到一种叫做prop drilling的情况，即将props传递到组件树的深处。重构依赖于props的代码几乎变得不可能，而且很难知道某些数据来自哪里。</p>
<p>假设我们有一个App组件，其中包含某些数据。在组件树的深处，我们有一个ListItem、Header和Text组件，它们都需要这些数据。为了将这些数据传递给这些组件，我们必须通过多个层次的组件传递它。</p>
<p>在我们的代码库中，这将类似于以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = &#123; ... &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">SideBar</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">SideBar</span> = (<span class="hljs-params">&#123; data &#125;</span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">List</span> = (<span class="hljs-params">&#123; data &#125;</span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ListItem</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">ListItem</span> = (<span class="hljs-params">&#123; data &#125;</span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;data.listItem&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Content</span> = (<span class="hljs-params">&#123; data &#125;</span>) =&gt; (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Block</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Header</span> = (<span class="hljs-params">&#123; data &#125;</span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;data.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Block</span> = (<span class="hljs-params">&#123; data &#125;</span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;data&#125;</span> /&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Text</span> = (<span class="hljs-params">&#123; data &#125;</span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;data.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br></code></pre></td></tr></table></figure>
<p>通过这种方式传递props可能会变得非常混乱。如果我们将来想要重命名数据prop，就必须在所有组件中进行重命名。随着应用程序变得越来越大，prop drilling就会变得越来越棘手。</p>
<p>如果我们能够跳过不需要使用这些数据的所有组件层级，那将是最理想的。我们需要有一种方法，让需要访问数据值的组件直接访问它，而不依赖于prop drilling。</p>
<p>这就是Provider模式可以帮助我们的地方！使用Provider模式，我们可以将数据提供给多个组件。而不是通过props将数据传递给每个层级，我们可以将所有组件包装在Provider中。Provider是由Context对象提供给我们的高阶组件。我们可以使用React为我们提供的createContext方法创建一个Context对象。</p>
<p>Provider接收一个value prop，其中包含我们要传递的数据。所有包装在此provider中的组件都可以访问value prop的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">DataContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>()<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = &#123; ... &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">DataContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;data&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">SideBar</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">DataContext.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们不再需要手动将数据传递给每个组件！那么，ListItem、Header和Text组件如何访问数据的值呢？</p>
<p>每个组件都可以通过使用useContext钩子来访问数据。这个钩子接收与数据相关联的上下文，本例中是DataContext。useContext钩子允许我们读取和写入上下文对象中的数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">DataContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = &#123; ... &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">SideBar</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">SideBar</span> = (<span class="hljs-params"></span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span> /&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">List</span> = (<span class="hljs-params"></span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ListItem</span> /&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Content</span> = (<span class="hljs-params"></span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Block</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListItem</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">DataContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;data.listItem&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Text</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">DataContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;data.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">DataContext</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;data.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那些不使用数据值的组件将不必处理数据。我们不再需要担心将props通过不需要这些props值的组件传递多层级，这样重构变得更加容易。</p>
<hr>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>提供者模式使得可以将数据传递给许多组件，而无需手动通过每个组件层传递数据。</p>
<p>在重构代码时，减少了意外引入错误的风险。以前，如果我们想要重命名一个属性，我们必须在使用该值的整个应用程序中重命名该属性。</p>
<p>我们不再需要处理属性传递的问题。以前，很难理解应用程序的数据流，因为并不总是清楚某些属性值的来源。使用提供者模式，我们不再需要将属性不必要地传递给不关心这些数据的组件。</p>
<p>使用提供者模式可以轻松地保持某种全局状态，因为我们可以让组件访问这个全局状态。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>在某些情况下，过度使用提供者模式可能会导致性能问题。所有使用上下文的组件在每次状态更改时都会重新渲染。</p>
<p>让我们看一个例子。我们有一个简单的计数器，每次我们点击按钮组件中的增加按钮时，值都会增加。我们还有一个重置按钮，在重置组件中，它将计数重置为0。</p>
<p>然而，当你点击增加时，你会发现不仅计数会重新渲染，重置组件中的日期也会重新渲染！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, createContext, useContext, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moment&quot;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./styles.css&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CountContext</span> = <span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Reset</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; setCount &#125; = <span class="hljs-title function_">useCountContext</span>();<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;app-col&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(0)&#125;&gt;Reset count<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Last reset: &#123;moment().format(&quot;h:mm:ss a&quot;)&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; count, setCount &#125; = <span class="hljs-title function_">useCountContext</span>();<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;app-col&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Current count: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useCountContext</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> context = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">CountContext</span>);<br>  <span class="hljs-keyword">if</span> (!context)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>      <span class="hljs-string">&quot;useCountContext has to be used within CountContextProvider&quot;</span><br>    );<br>  <span class="hljs-keyword">return</span> context;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CountContextProvider</span>(<span class="hljs-params">&#123; children &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CountContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">count</span>, <span class="hljs-attr">setCount</span> &#125;&#125;&gt;</span></span><br><span class="language-xml">      &#123;children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">CountContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">CountContextProvider</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Reset</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">CountContextProvider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>));<br><br></code></pre></td></tr></table></figure>
<p>Reset组件也重新渲染了，因为它使用了useCountContext。在较小的应用程序中，这不会太重要。但在较大的应用程序中，将频繁更新的值传递给许多组件可能会对性能产生负面影响。</p>
<p>为了确保组件不会消耗包含可能更新的不必要值的提供者，可以为每个单独的用例创建多个提供者。或者使用useRef, 比对变化属性, 当关心的属性变化时才进行更新。</p>
]]></content>
      <categories>
        <category>Patterns</category>
      </categories>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/posts/5fa45d82.html</url>
    <content><![CDATA[<h2 id="【译】观察者模式Observer-Pattern"><a href="#【译】观察者模式Observer-Pattern" class="headerlink" title="【译】观察者模式Observer Pattern"></a>【译】观察者模式<a href="https://www.patterns.dev/vanilla/observer-pattern">Observer Pattern</a></h2><p>观察者模式中，我们可以将某些对象（观察者）注册到另一个对象（被观察者）上。每当事件发生时，被观察者会通知所有的观察者！</p>
<hr>
<p>一个可观察对象通常包含三个重要部分：</p>
<ul>
<li>observers：一个观察者数组，当特定事件发生时会通知这些观察者。</li>
<li>subscribe()：用于将观察者添加到观察者列表的方法。</li>
<li>unsubscribe()：用于从观察者列表中移除观察者的方法。</li>
<li>notify()：当特定事件发生时，通知所有观察者的方法。</li>
</ul>
<p>太好了，让我们创建一个可观察对象！创建一个可观察对象的简单方法是使用ES6类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observable</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = [];<br>  &#125;<br><br>  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">func</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(func);<br>  &#125;<br><br>  <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">func</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">observer</span>) =&gt;</span> observer !== func);<br>  &#125;<br><br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">observer</span>) =&gt;</span> <span class="hljs-title function_">observer</span>(data));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>太棒了！现在我们可以使用subscribe方法将观察者添加到观察者列表中，使用unsubscribe方法移除观察者，并使用notify方法通知所有订阅者。</p>
<p>让我们使用这个可观察对象构建一些东西。我们有一个非常基本的应用程序，只包含两个组件：一个按钮和一个开关。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FormControlLabel</span> <span class="hljs-attr">control</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Switch</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们想要跟踪用户与应用程序的交互。每当用户点击按钮或切换开关时，我们希望记录此事件的时间戳。除了记录它，我们还希望创建一个弹出通知，每当事件发生时显示出来！</p>
<p>基本上，我们想要做的是以下内容：</p>
<p>每当用户调用handleClick或handleToggle函数时，这些函数会在观察者上调用notify方法。notify方法使用handleClick或handleToggle函数传递的数据通知所有订阅者！</p>
<p>首先，让我们创建logger和toastify函数。这些函数最终将从notify方法接收数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ToastContainer</span>, toast &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-toastify&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span> <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">toastify</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-title function_">toast</span>(data);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FormControlLabel</span> <span class="hljs-attr">control</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Switch</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ToastContainer</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>目前，logger和toastify函数还不知道observable：observable还不能通知它们！为了使它们成为观察者，我们需要使用observable上的subscribe方法订阅它们！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ToastContainer</span>, toast &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-toastify&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span> <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">toastify</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-title function_">toast</span>(data);<br>&#125;<br><br>observable.<span class="hljs-title function_">subscribe</span>(logger);<br>observable.<span class="hljs-title function_">subscribe</span>(toastify);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FormControlLabel</span> <span class="hljs-attr">control</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Switch</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ToastContainer</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>每当发生事件时，logger和toastify函数将收到通知。现在我们只需要实现实际通知observable的函数：handleClick和handleToggle函数！这些函数应该在observable上调用notify方法，并传递观察者应该接收的数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ToastContainer</span>, toast &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-toastify&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span> <span class="hljs-subst">$&#123;data&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">toastify</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-title function_">toast</span>(data);<br>&#125;<br><br>observable.<span class="hljs-title function_">subscribe</span>(logger);<br>observable.<span class="hljs-title function_">subscribe</span>(toastify);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>    observable.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&quot;User clicked button!&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleToggle</span>(<span class="hljs-params"></span>) &#123;<br>    observable.<span class="hljs-title function_">notify</span>(<span class="hljs-string">&quot;User toggled switch!&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FormControlLabel</span> <span class="hljs-attr">control</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Switch</span> /&gt;</span>&#125; /&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ToastContainer</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>太棒了！我们刚刚完成了整个流程：handleClick和handleToggle调用观察者上的notify方法, 传递数据，然后观察者通知订阅者：在这种情况下是logger和toastify函数。</p>
<p>虽然我们可以以许多方式使用观察者模式，但在处理异步、基于事件的数据时，它非常有用。也许您希望在某些数据下载完成时通知特定组件，或者在用户向留言板发送新消息时通知所有其他成员。观察者模式允许主题（可观察对象）和观察者之间的松耦合。这意味着主题不需要直接了解观察者，观察者可以轻松添加或删除而不影响主题。</p>
<hr>
<h3 id="案例研究"><a href="#案例研究" class="headerlink" title="案例研究"></a>案例研究</h3><p>一个使用观察者模式的流行库是RxJS。</p>
<blockquote>
<p>ReactiveX将观察者模式与迭代器模式和函数式编程与集合相结合，以满足管理事件序列的理想方式的需求。- RxJS</p>
</blockquote>
<p>使用RxJS，我们可以创建可观察对象并订阅特定的事件！让我们看一个在他们的文档中涵盖的例子，它记录用户是否在文档中拖动。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; fromEvent, merge &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rxjs&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; sample, mapTo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rxjs/operators&quot;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./styles.css&quot;</span>;<br><br><span class="hljs-title function_">merge</span>(<br>  <span class="hljs-title function_">fromEvent</span>(<span class="hljs-variable language_">document</span>, <span class="hljs-string">&quot;mousedown&quot;</span>).<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">mapTo</span>(<span class="hljs-literal">false</span>)),<br>  <span class="hljs-title function_">fromEvent</span>(<span class="hljs-variable language_">document</span>, <span class="hljs-string">&quot;mousemove&quot;</span>).<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">mapTo</span>(<span class="hljs-literal">true</span>))<br>)<br>  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">sample</span>(<span class="hljs-title function_">fromEvent</span>(<span class="hljs-variable language_">document</span>, <span class="hljs-string">&quot;mouseup&quot;</span>)))<br>  .<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">isDragging</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Were you dragging?&quot;</span>, isDragging);<br>  &#125;);<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span>Click or drag anywhere and check the console!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>)<br>);<br><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>使用观察者模式是实现关注点分离和单一职责原则的好方法。观察者对象与被观察对象没有紧密耦合，可以在任何时候进行解耦。被观察对象负责监控事件，而观察者只需处理接收到的数据。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>如果观察者变得过于复杂，当通知所有订阅者时可能会导致性能问题。</p>
]]></content>
      <categories>
        <category>Patterns</category>
      </categories>
  </entry>
  <entry>
    <title>react源码学习-beginWork-dom-diff</title>
    <url>/posts/cd6ab115.html</url>
    <content><![CDATA[<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>mount时，由于没有旧节点，dom-diff直接根据jsx element 创建新fiber的直连子链表 child<br>更新时，dom-diff打标签</p>
<p>reconcileChildrenArray是关键，dom-diff 会产生插入tag, 给父fiber删除tag，没有更新。</p>
<ol>
<li>删除就是，给父fiber一个删除标记，旧fiber在旧fiber树里不用动，标记就行，commit阶段删真实dom</li>
<li>插入就是，创建一个fiber，放到新fiber树里，标记当前fiber插入</li>
<li>移动就是，创建一个fiber，放到新fiber树里，标记当前fiber插入<br>移动就是插入<br>复用这个老fiber放入新fiber树里，数组位置变了，关联新fiber树，上个fiber的sibling</li>
</ol>
<h3 id="单节点dom-diff"><a href="#单节点dom-diff" class="headerlink" title="单节点dom-diff"></a>单节点dom-diff</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 单节点dom-diff</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * 新fiber是单节点，老fiber可能是数组</span><br><span class="hljs-comment">  * old fibers [1, 2, 3]  new fiber [2]</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * 1. 如果key, type相同，则复用，删除旧fiber数组剩下的fiber</span><br><span class="hljs-comment">  * 2. 如果key不同，删除这个老fiber(commit阶段递归删除整个子树)，继续遍历旧的fiber数组</span><br><span class="hljs-comment">  * 3. 如果key相同，type不同，删除fiber数组剩下的fiber，创建一个新的。删除操作都是直接删除当前为根的子树</span><br><span class="hljs-comment">  * 4. 没有老fiber, mount时，根据element创建fiber挂载到returnFiber</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; returnFiber 父fiber</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; currentFirstChild 子fiber链表第一个fiber 老fiber链表</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; element 父fiber的dom的child</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@returns</span></span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileSingleElement</span>(<span class="hljs-params">returnFiber, currentFirstChild, element</span>) &#123;<br>   <span class="hljs-comment">// 单节点dom diff</span><br>   <span class="hljs-comment">// 新fiber的key</span><br>   <span class="hljs-keyword">const</span> key = element.<span class="hljs-property">key</span>;<br>   <span class="hljs-comment">// 新fiber的type</span><br>   <span class="hljs-keyword">const</span> type = element.<span class="hljs-property">type</span>;<br>   <span class="hljs-comment">// 老fiber</span><br>   <span class="hljs-keyword">let</span> child = currentFirstChild;<br>   <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) &#123;<br>     <span class="hljs-keyword">if</span> (child.<span class="hljs-property">key</span> === key) &#123;<br>       <span class="hljs-keyword">if</span> (child.<span class="hljs-property">type</span> === type) &#123;<br>         <span class="hljs-comment">// 删除老fiber之后的所有sibling节点</span><br>         <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, child.<span class="hljs-property">sibling</span>);<br>         <span class="hljs-comment">// 如果key和类型一样，则复用</span><br>         <span class="hljs-keyword">const</span> existing = <span class="hljs-title function_">useFiber</span>(child, element.<span class="hljs-property">props</span>);<br>         existing.<span class="hljs-property">ref</span> = element.<span class="hljs-property">ref</span>;<br>         existing.<span class="hljs-property">return</span> = returnFiber;<br>         <span class="hljs-keyword">return</span> existing;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// 如果key相同，type不同，这个老fiber要删除，换新类型的fiber</span><br>         <span class="hljs-comment">// 找到了一个之后的老fiber都不用看了，直接清空跳出循环，走创建fiber的逻辑</span><br>         <span class="hljs-comment">// go to createFiberFromElement</span><br>         <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, child);<br>       &#125;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-title function_">deleteChild</span>(returnFiber, child);<br>     &#125;<br>     child = child.<span class="hljs-property">sibling</span>;<br>   &#125;<br><br>   <span class="hljs-keyword">const</span> created = <span class="hljs-title function_">createFiberFromElement</span>(element);<br>   created.<span class="hljs-property">ref</span> = element.<span class="hljs-property">ref</span>;<br>   created.<span class="hljs-property">return</span> = returnFiber;<br>   <span class="hljs-keyword">return</span> created;<br> &#125;<br></code></pre></td></tr></table></figure>

<h3 id="多节点dom-diff"><a href="#多节点dom-diff" class="headerlink" title="多节点dom-diff"></a>多节点dom-diff</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * DOM DIFF的三个规则</span><br><span class="hljs-comment">  * 只对同级元素进行比较，不同层级不对比</span><br><span class="hljs-comment">  * 不同的类型对应不同的元素，直接整个子树删除</span><br><span class="hljs-comment">  * 可以通过key来标识同一个节点，通过map来移动复用</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * 第1轮遍历</span><br><span class="hljs-comment">  * key不同，直接结束本轮循环，第2轮循环 (*)</span><br><span class="hljs-comment">  * key相同，type不同，标记老fiber删除, 创建新的fiber，继续循环</span><br><span class="hljs-comment">  * key相同，type也相同，复用老fiber, 继续循环</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * 第2轮遍历</span><br><span class="hljs-comment">  * 如果有1个结束了</span><br><span class="hljs-comment">  *   newChildren遍历完，oldFiber还有，将剩下oldFiber标记删除，diff结束</span><br><span class="hljs-comment">  *   oldFiber遍历完了，newChildren还有，将剩下newChildren标记插入，diff结束</span><br><span class="hljs-comment">  * newChildren和oldFiber都遍历完成，diff结束</span><br><span class="hljs-comment">  * newChildren和oldFiber都还有节点，第3轮循环，节点移动(*)</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * 第3轮遍历</span><br><span class="hljs-comment">  * key不同跳出第1个循环，并且新旧2个链表都有剩余</span><br><span class="hljs-comment">  * 用map记录，key:oldFiber记录到map</span><br><span class="hljs-comment">  * 从前往后遍历，如果这个节点在前面位置，则复用移动过来</span><br><span class="hljs-comment">  * 如果没有能复用的，则创建</span><br><span class="hljs-comment">  * 如果多余了，则删除</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * mount阶段，olderFiber一个没有，在第二轮循环直接全部创建新fiber</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; returnFiber 父fiber</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; currentFirstChild newChildren对于的旧fiber</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; newChildren 父fiber第一个child</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@returns</span></span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileChildrenArray</span>(<span class="hljs-params">returnFiber, currentFirstChild, newChildren</span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>     <span class="hljs-string">&quot;reconcileChildrenArray returnFiber&quot;</span>,<br>     returnFiber,<br>     currentFirstChild,<br>     newChildren<br>   );<br>   <span class="hljs-keyword">let</span> resultingFirstChild = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 新fiber链表的第一个节点</span><br>   <span class="hljs-keyword">let</span> previousNewFiber = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 新fiber链表的最后一个节点</span><br><br>   <span class="hljs-keyword">let</span> newIdx = <span class="hljs-number">0</span>; <span class="hljs-comment">// 遍历新child数组的指针</span><br><br>   <span class="hljs-keyword">let</span> oldFiber = currentFirstChild; <span class="hljs-comment">//  遍历老fiber链表的指针 初始第一个老fiber</span><br>   <span class="hljs-keyword">let</span> nextOldFiber = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 遍历老fiber链表的下一个指针</span><br><br>   <span class="hljs-keyword">let</span> lastPlacedIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// 上一个不需要移动的节点的索引</span><br><br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;first loop. try to reuse.&quot;</span>);<br>   <span class="hljs-keyword">for</span> (; oldFiber !== <span class="hljs-literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) &#123;<br>     nextOldFiber = oldFiber.<span class="hljs-property">sibling</span>;<br><br>     <span class="hljs-comment">// 试图更新或者复用老fiber</span><br>     <span class="hljs-keyword">const</span> newFiber = <span class="hljs-title function_">updateSlot</span>(returnFiber, oldFiber, newChildren[newIdx]);<br>     <span class="hljs-keyword">if</span> (newFiber === <span class="hljs-literal">null</span>) &#123;<br>       <span class="hljs-keyword">break</span>;<br>     &#125;<br>     <span class="hljs-keyword">if</span> (shouldTrackSideEffects) &#123;<br>       <span class="hljs-comment">// 如果有老fiber, 但是新的fiber并没有成功复用，就标记删除老fiber samekeydifferenttype 1</span><br>       <span class="hljs-keyword">if</span> (oldFiber &amp;&amp; newFiber.<span class="hljs-property">alternate</span> === <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-title function_">deleteChild</span>(returnFiber, oldFiber);<br>       &#125;<br>     &#125;<br>     <span class="hljs-comment">// 指定fiber的位置, 并标记插入</span><br>     lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);<br>     <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) &#123;<br>       resultingFirstChild = newFiber;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       previousNewFiber.<span class="hljs-property">sibling</span> = newFiber;<br>     &#125;<br>     previousNewFiber = newFiber;<br>     oldFiber = nextOldFiber;<br>   &#125;<br><br>   <span class="hljs-comment">// 如果新fiber已经没有了，旧fiber链表还有，将old链表剩下的全删掉</span><br>   <span class="hljs-keyword">if</span> (newIdx === newChildren.<span class="hljs-property">length</span>) &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;new fibers is done. delete remaining old fiber&quot;</span>, oldFiber);<br>     <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);<br>     <span class="hljs-keyword">return</span> resultingFirstChild;<br>   &#125;<br><br>   <span class="hljs-keyword">if</span> (oldFiber === <span class="hljs-literal">null</span>) &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;no old fiber. create remaining fibers&quot;</span>);<br>     <span class="hljs-comment">// 如果老fiber已经没有了，新虚拟dom还有，插入剩下的新节点</span><br>     <span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) &#123;<br>       <span class="hljs-keyword">const</span> newFiber = <span class="hljs-title function_">createChild</span>(returnFiber, newChildren[newIdx]);<br>       <span class="hljs-keyword">if</span> (newFiber === <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br>       <span class="hljs-comment">// 加index 和 flags</span><br>       lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);<br><br>       <span class="hljs-comment">// child fiber链表</span><br>       <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) &#123;<br>         resultingFirstChild = newFiber;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>         previousNewFiber.<span class="hljs-property">sibling</span> = newFiber;<br>       &#125;<br>       previousNewFiber = newFiber;<br>     &#125;<br>   &#125;<br><br>   <span class="hljs-comment">// 开始处理移动的情况</span><br>   <span class="hljs-keyword">const</span> existingChildren = <span class="hljs-title function_">mapRemainingChildren</span>(returnFiber, oldFiber);<br>   <span class="hljs-comment">// 开始遍历剩下的虚拟dom子节点</span><br>   <span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;move reuse.&quot;</span>);<br>     <span class="hljs-comment">// 移动复用或创建新节点</span><br>     <span class="hljs-keyword">const</span> newFiber = <span class="hljs-title function_">updateFromMap</span>(<br>       existingChildren,<br>       returnFiber,<br>       newIdx,<br>       newChildren[newIdx]<br>     );<br>     <span class="hljs-keyword">if</span> (newFiber !== <span class="hljs-literal">null</span>) &#123;<br>       <span class="hljs-keyword">if</span> (shouldTrackSideEffects) &#123;<br>         <span class="hljs-comment">// 移动复用了的老fiber 从fiber删除</span><br>         <span class="hljs-keyword">if</span> (newFiber.<span class="hljs-property">alternate</span> !== <span class="hljs-literal">null</span>) &#123;<br>           existingChildren.<span class="hljs-title function_">delete</span>(<br>             newFiber.<span class="hljs-property">key</span> === <span class="hljs-literal">null</span> ? newIdx : newFiber.<span class="hljs-property">key</span><br>           );<br>         &#125;<br>       &#125;<br>       <span class="hljs-comment">// 标记插入，也就是移动，将原dom插入到另一个位置就是移动</span><br>       lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);<br>       <span class="hljs-comment">// newFiber挂到链表里</span><br>       <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) &#123;<br>         resultingFirstChild = newFiber;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>         previousNewFiber.<span class="hljs-property">sibling</span> = newFiber;<br>       &#125;<br>       previousNewFiber = newFiber;<br>     &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">if</span> (shouldTrackSideEffects) &#123;<br>     <span class="hljs-comment">// map剩下的全部删除</span><br>     existingChildren.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> <span class="hljs-title function_">deleteChild</span>(returnFiber, child));<br>   &#125;<br><br>   <span class="hljs-keyword">return</span> resultingFirstChild;<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/posts/5be0a306.html</url>
    <content><![CDATA[<h2 id="【译】代理模式Proxy-Pattern"><a href="#【译】代理模式Proxy-Pattern" class="headerlink" title="【译】代理模式Proxy Pattern"></a>【译】代理模式<a href="https://www.patterns.dev/vanilla/proxy-pattern">Proxy Pattern</a></h2><p>通过代理对象，我们可以更好地控制与某些对象的交互。代理对象可以确定我们与对象交互时的行为，例如获取值或设置值时。</p>
<p>一般来说，代理意味着替身。与直接与某人交谈不同，你将与代理人交谈，代理人将代表你试图联系的人。在JavaScript中也是如此：我们不直接与目标对象交互，而是与代理对象交互。</p>
<hr>
<p>让我们创建一个表示John Doe的Person对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">42</span>,<br>  <span class="hljs-attr">nationality</span>: <span class="hljs-string">&quot;American&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>与直接与这个对象交互不同，我们希望与一个代理对象交互。在JavaScript中，我们可以通过创建Proxy的新实例来轻松创建一个新的代理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">42</span>,<br>  <span class="hljs-attr">nationality</span>: <span class="hljs-string">&quot;American&quot;</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> personProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(person, &#123;&#125;);<br></code></pre></td></tr></table></figure>
<p>Proxy的第二个参数是一个表示处理程序的对象。在处理程序对象中，我们可以根据交互类型定义特定的行为。虽然你可以在Proxy处理程序中添加许多方法，但最常见的两个方法是get和set：</p>
<ul>
<li>get：在尝试访问属性时调用</li>
<li>set：在尝试修改属性时调用</li>
</ul>
<p>实际上，最终会发生以下情况：</p>
<p><img src="/pic/proxy-set.png" alt="proxy-set"></p>
<p>与直接与person对象交互不同，我们将与personProxy代理对象交互。</p>
<p>让我们为personProxy代理对象添加处理程序。当尝试修改属性时，即调用Proxy的set方法时，我们希望代理记录属性的先前值和新值。当尝试访问属性时，即调用Proxy的get方法时，我们希望代理记录一个更可读的句子，其中包含属性的键和值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> personProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(person, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`The value of <span class="hljs-subst">$&#123;prop&#125;</span> is <span class="hljs-subst">$&#123;obj[prop]&#125;</span>`</span>);<br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop, value</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Changed <span class="hljs-subst">$&#123;prop&#125;</span> from <span class="hljs-subst">$&#123;obj[prop]&#125;</span> to <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    obj[prop] = value;<br>  &#125;,<br>&#125;);<br><br>personProxy.<span class="hljs-property">name</span>;<br><br>personProxy.<span class="hljs-property">age</span> = <span class="hljs-number">43</span>;<br><br><span class="hljs-comment">// The value of name is John Doe</span><br><span class="hljs-comment">// Changed age from 42 to 43</span><br></code></pre></td></tr></table></figure>

<p>完美！让我们看看当我们尝试修改或检索属性时会发生什么。</p>
<p>当访问name属性时，代理返回了一个更好听的句子：name的值是John Doe。</p>
<p>当修改age属性时，代理返回了该属性的先前值和新值：将age从42更改为43。</p>
<hr>
<p>代理可以用于添加验证。用户不应该能够将person的年龄更改为字符串值，或者给他们一个空的名字。或者如果用户尝试访问对象上不存在的属性，我们应该让用户知道。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">42</span>,<br>  <span class="hljs-attr">nationality</span>: <span class="hljs-string">&quot;American&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> personProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(person, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj[prop]) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hmm.. this property doesn&#x27;t seem to exist`</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`The value of <span class="hljs-subst">$&#123;prop&#125;</span> is <span class="hljs-subst">$&#123;obj[prop]&#125;</span>`</span>);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop, value</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">&quot;age&quot;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Sorry, you can only pass numeric values for age.`</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">&quot;name&quot;</span> &amp;&amp; value.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`You need to provide a valid name.`</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Changed <span class="hljs-subst">$&#123;prop&#125;</span> from <span class="hljs-subst">$&#123;obj[prop]&#125;</span> to <span class="hljs-subst">$&#123;value&#125;</span>.`</span>);<br>      obj[prop] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;);<br><br>personProxy.<span class="hljs-property">nonExistentProperty</span>;<br>personProxy.<span class="hljs-property">age</span> = <span class="hljs-string">&quot;44&quot;</span>;<br>personProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">// Hmm.. this property doesn&#x27;t seem to exist </span><br><span class="hljs-comment">// Sorry, you can only pass numeric values for age. </span><br><span class="hljs-comment">// You need to provide a valid name. </span><br><br></code></pre></td></tr></table></figure>

<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>JavaScript提供了一个内置对象叫做Reflect，它使我们在使用代理时更容易操作目标对象。</p>
<p>之前，我们尝试通过直接使用方括号表示法来修改和访问代理中的目标对象上的属性。现在，我们可以使用Reflect对象。Reflect对象上的方法与处理程序对象上的方法同名。</p>
<p>我们可以通过Reflect.get()和Reflect.set()来访问或修改目标对象上的属性，而不是通过obj[prop]来访问属性或通过obj[prop] &#x3D; value来设置属性。这些方法接收与处理程序对象上的方法相同的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> personProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(person, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`The value of <span class="hljs-subst">$&#123;prop&#125;</span> is <span class="hljs-subst">$&#123;<span class="hljs-built_in">Reflect</span>.get(obj, prop)&#125;</span>`</span>);<br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop, value</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Changed <span class="hljs-subst">$&#123;prop&#125;</span> from <span class="hljs-subst">$&#123;obj[prop]&#125;</span> to <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(obj, prop, value);<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>完美！我们可以通过Reflect对象轻松地访问和修改目标对象上的属性。</p>
<h3 id="权衡利弊"><a href="#权衡利弊" class="headerlink" title="权衡利弊"></a>权衡利弊</h3><p>代理是一种强大的方式，可以对对象的行为进行控制。代理可以有各种用途：它可以帮助进行验证、格式化、通知或调试。</p>
<p>过度使用代理对象或在每个处理程序方法调用上执行繁重操作可能会对应用程序的性能产生负面影响。最好不要在性能关键的代码中使用代理。</p>
]]></content>
      <categories>
        <category>Patterns</category>
      </categories>
  </entry>
  <entry>
    <title>react源码学习-commitRoot</title>
    <url>/posts/83169b38.html</url>
    <content><![CDATA[<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>commit阶段必须同步执行，一把修改完dom, 等下次浏览器渲染执行Dom-Style-Layout-Layer-Paint-Raster-GPU，显卡读取</p>
<ol>
<li>useEffect的effect放到schedule队列中，宏任务执行</li>
<li>递归执行标记的dom修改 （删除和插入操作）,此时顺便把useLayoutEffect destory递归执行了</li>
<li>递归执行所有fiber的layout effect链表的create，useLayout执行会阻塞本次dom修改结果的渲染</li>
</ol>
<p>layout effect 和 passive effect通过effect的tag字段区别</p>
<p>finishedWork.updateQueue.lastEffect 指向effect循环链表最后一个，也就是effect链表存储在fiber上</p>
<h3 id="useEffect调度执行"><a href="#useEffect调度执行" class="headerlink" title="useEffect调度执行"></a>useEffect调度执行</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 放到下一个宏任务执行</span><br> <span class="hljs-title class_">Scheduler</span>_scheduleCallback(<span class="hljs-title class_">NormalSchedulerPriority</span>, flushPassiveEffect);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushPassiveEffect</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (rootWithPendingPassiveEffects !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 缓存中取root</span><br>    <span class="hljs-keyword">const</span> root = rootWithPendingPassiveEffects;<br>    <span class="hljs-comment">// 执行卸载副作用，useEffect的destroy</span><br>    <span class="hljs-title function_">commitPassiveUnmountEffects</span>(root.<span class="hljs-property">current</span>);<br>    <span class="hljs-comment">// 执行挂载副作用，useEffect的create</span><br>    <span class="hljs-title function_">commitPassiveMountEffects</span>(root, root.<span class="hljs-property">current</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 递归执行fiber树的所有fiber的effect链表的destroy</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitPassiveUnmountEffects</span>(<span class="hljs-params">finishedWork</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;recursive run effect destroy&quot;</span>);<br>  <span class="hljs-title function_">commitPassiveUnmountOnFiber</span>(finishedWork);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitPassiveUnmountOnFiber</span>(<span class="hljs-params">finishedWork</span>) &#123;<br>  <span class="hljs-keyword">const</span> flags = finishedWork.<span class="hljs-property">flags</span>;<br>  <span class="hljs-keyword">switch</span> (finishedWork.<span class="hljs-property">tag</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>: &#123;<br>      <span class="hljs-title function_">recursivelyTraversePassiveUnmountEffects</span>(finishedWork);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>: &#123;<br>      <span class="hljs-title function_">recursivelyTraversePassiveUnmountEffects</span>(finishedWork);<br>      <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">Passive</span>) &#123;<br>        <span class="hljs-title function_">commitHookPassiveUnmountEffects</span>(<br>          finishedWork,<br>          <span class="hljs-title class_">HookHasEffect</span> | <span class="hljs-title class_">HookPassive</span><br>        );<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 递归执行fiber树的所有fiber的effect链表的create</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitPassiveMountEffects</span>(<span class="hljs-params">root, finishedWork</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;recursive run effect create&quot;</span>);<br>  <span class="hljs-title function_">commitPassiveMountOnFiber</span>(root, finishedWork);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递归执行fiber树的所有fiber的effect链表的create</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; finishedRoot root FiberRootNode</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; finishedWork root.current HostRootFiber</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitPassiveMountOnFiber</span>(<span class="hljs-params">finishedRoot, finishedWork</span>) &#123;<br>  <span class="hljs-keyword">const</span> flags = finishedWork.<span class="hljs-property">flags</span>;<br>  <span class="hljs-keyword">switch</span> (finishedWork.<span class="hljs-property">tag</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>: &#123;<br>      <span class="hljs-title function_">recursivelyTraversePassiveMountEffects</span>(finishedRoot, finishedWork);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>: &#123;<br>      <span class="hljs-title function_">recursivelyTraversePassiveMountEffects</span>(finishedRoot, finishedWork);<br>      <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">Passive</span>) &#123;<br>        <span class="hljs-comment">// Passive 1024  多一步执行effect链表</span><br>        <span class="hljs-title function_">commitHookPassiveMountEffects</span>(<br>          finishedWork,<br>          <span class="hljs-title class_">HookPassive</span> | <span class="hljs-title class_">HookHasEffect</span><br>        );<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="执行dom修改"><a href="#执行dom修改" class="headerlink" title="执行dom修改"></a>执行dom修改</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">// dom变更后 只是改了dom, 浏览器后面执行渲染</span><br> <span class="hljs-title function_">commitMutationEffectsOnFiber</span>(finishedWork, root);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * commitMutationEffectsOnFiber + recursivelyTraverseMutationEffects 2个函数进行递归</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 处理子节点打的effect tag</span><br><span class="hljs-comment"> * 1. 删除子节点</span><br><span class="hljs-comment"> * 2. 递归处理子节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; root 容器根节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; parentFiber 当前要处理副作用的fiber</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">recursivelyTraverseMutationEffects</span>(<span class="hljs-params">root, parentFiber</span>) &#123;<br>  <span class="hljs-keyword">const</span> deletions = parentFiber.<span class="hljs-property">deletions</span>;<br>  <span class="hljs-comment">// 如果子节点有删除，处理删除，在父节点删子节点</span><br>  <span class="hljs-keyword">if</span> (deletions !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; deletions.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">const</span> childToDelete = deletions[i];<br>      <span class="hljs-title function_">commitDeletionEffects</span>(root, parentFiber, childToDelete);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 递归处理effect</span><br>  <span class="hljs-keyword">if</span> (parentFiber.<span class="hljs-property">subtreeFlags</span> &amp; <span class="hljs-title class_">MutationMask</span>) &#123;<br>    <span class="hljs-keyword">let</span> &#123; child &#125; = parentFiber;<br>    <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-title function_">commitMutationEffectsOnFiber</span>(child, root);<br>      child = child.<span class="hljs-property">sibling</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 遍历fiber树，执行fiber上的副作用</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; finishedWork fiber节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; root 根节点</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitMutationEffectsOnFiber</span>(<span class="hljs-params">finishedWork, root</span>) &#123;<br>  <span class="hljs-comment">// 老fiber</span><br>  <span class="hljs-keyword">const</span> current = finishedWork.<span class="hljs-property">alternate</span>;<br>  <span class="hljs-comment">// 更新tag</span><br>  <span class="hljs-keyword">const</span> flags = finishedWork.<span class="hljs-property">flags</span>;<br><br>  <span class="hljs-keyword">switch</span> (finishedWork.<span class="hljs-property">tag</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>: &#123;<br>      <span class="hljs-comment">// 先处理子节点副作用 递归</span><br>      <span class="hljs-title function_">recursivelyTraverseMutationEffects</span>(root, finishedWork);<br>      <span class="hljs-comment">// 处理自身的副作用</span><br>      <span class="hljs-title function_">commitReconciliationEffects</span>(finishedWork);<br>      <span class="hljs-comment">// 执行useLayoutEffect 的destroy</span><br>      <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">Update</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;recursive run layout effect destroy&quot;</span>);<br>        <span class="hljs-title function_">commitHookEffectListUnmount</span>(<span class="hljs-title class_">HookHasEffect</span> | <span class="hljs-title class_">HookLayout</span>, finishedWork);<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    ...<br><br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitReconciliationEffects</span>(<span class="hljs-params">finishedWork</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; flags &#125; = finishedWork;<br>  <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">Placement</span>) &#123;<br>    <span class="hljs-comment">// 执行插入操作，（移动和新建）</span><br>    <span class="hljs-title function_">commitPlacement</span>(finishedWork);<br>    <span class="hljs-comment">// 清除effect</span><br>    finishedWork.<span class="hljs-property">flags</span> = finishedWork.<span class="hljs-property">flags</span> &amp; ~<span class="hljs-title class_">Placement</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="useLayout执行"><a href="#useLayout执行" class="headerlink" title="useLayout执行"></a>useLayout执行</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">  <span class="hljs-comment">// 执行layout effect create</span><br>  <span class="hljs-title function_">commitLayoutEffects</span>(finishedWork, root);<br><br><span class="hljs-comment">// 递归执行所有fiber的layout effect链表</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitLayoutEffectOnFiber</span>(<span class="hljs-params">finishedRoot, current, finishedWork</span>) &#123;<br>  <span class="hljs-keyword">const</span> flags = finishedWork.<span class="hljs-property">flags</span>;<br>  <span class="hljs-keyword">switch</span> (finishedWork.<span class="hljs-property">tag</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>: &#123;<br>      <span class="hljs-title function_">recursivelyTraverseLayoutEffects</span>(finishedRoot, finishedWork);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>: &#123;<br>      <span class="hljs-title function_">recursivelyTraverseLayoutEffects</span>(finishedRoot, finishedWork);<br>      <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">LayoutMask</span>) &#123;<br>        <span class="hljs-comment">// Passive 1024  多一步执行effect链表</span><br>        <span class="hljs-title function_">commitHookLayoutEffects</span>(finishedWork, <span class="hljs-title class_">HookHasEffect</span> | <span class="hljs-title class_">HookLayout</span>);<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">recursivelyTraverseLayoutEffects</span>(<span class="hljs-params">root, parentFiber</span>) &#123;<br>  <span class="hljs-keyword">if</span> (parentFiber.<span class="hljs-property">subtreeFlags</span> &amp; <span class="hljs-title class_">LayoutMask</span>) &#123;<br>    <span class="hljs-keyword">let</span> child = parentFiber.<span class="hljs-property">child</span>;<br>    <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">const</span> current = child.<span class="hljs-property">alternate</span>;<br>      <span class="hljs-title function_">commitLayoutEffectOnFiber</span>(root, current, child);<br>      child = child.<span class="hljs-property">sibling</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>react源码学习-completeWork</title>
    <url>/posts/9c9d9a17.html</url>
    <content><![CDATA[<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>mount阶段，beginWork创建了fiber，做了一个优化，离线好构建dom树，最后插入容器dom, commit阶段只需执行一次插入，不用再次遍历整个树</p>
<p>更新阶段，beginWork进行dom-diff更新了fiber，还有props style 需要更新到dom上，所以还需要标记哪些属性要更新，将更新放到fiber.updateQueue，在commitRoot&#x3D;&gt;commitMutationEffectsOnFiber执行</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * mount阶段，创建dom, 设置jsx element的props到dom</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; current 老fiber</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; workInProgress 新fiber</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">completeWork</span>(<span class="hljs-params">current, workInProgress</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;completeWork&quot;</span>, current);<br>  <span class="hljs-keyword">const</span> newProps = workInProgress.<span class="hljs-property">pendingProps</span>;<br>  <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:<br>      <span class="hljs-title function_">bubbleProperties</span>(workInProgress);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostText</span>:<br>      <span class="hljs-comment">// 如果是文本节点的fiber，创建真实文本节点dom放到fiber.stateNode</span><br>      <span class="hljs-keyword">const</span> newText = newProps;<br>      workInProgress.<span class="hljs-property">stateNode</span> = <span class="hljs-title function_">createTextInstance</span>(newText);<br>      <span class="hljs-title function_">bubbleProperties</span>(workInProgress);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:<br>      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; workInProgress.<span class="hljs-property">stateNode</span> !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 更新阶段</span><br>        <span class="hljs-comment">// 如果老fiber存在，并且老fiber上有真实dom</span><br>        <span class="hljs-keyword">const</span> &#123; type &#125; = workInProgress;<br>        <span class="hljs-title function_">updateHostComponent</span>(current, workInProgress, type, newProps);<br><br>        <span class="hljs-comment">// 前后ref对象地址不同，标记要更新ref</span><br>        <span class="hljs-keyword">if</span> (current.<span class="hljs-property">ref</span> !== workInProgress.<span class="hljs-property">ref</span> &amp;&amp; workInProgress.<span class="hljs-property">ref</span> !== <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-title function_">markRef</span>(workInProgress);<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// mount阶段</span><br>        <span class="hljs-comment">// 如果是原生节点的fiber，创建dom放到fiber.stateNode</span><br>        <span class="hljs-keyword">const</span> &#123; type &#125; = workInProgress;<br>        <span class="hljs-keyword">const</span> instance = <span class="hljs-title function_">createInstance</span>(type, newProps, workInProgress);<br>        workInProgress.<span class="hljs-property">stateNode</span> = instance;<br><br>        <span class="hljs-comment">// 把自己所有的子节点dom添加到自己的身上</span><br>        <span class="hljs-title function_">appendAllChildren</span>(instance, workInProgress);<br><br>        <span class="hljs-comment">// 将prop 设置到dom上</span><br>        <span class="hljs-title function_">finalizeInitialChildren</span>(instance, type, newProps);<br><br>        <span class="hljs-comment">// 标记要挂载ref</span><br>        <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">ref</span> !== <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-title function_">markRef</span>(workInProgress);<br>        &#125;<br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:<br>      <span class="hljs-title function_">bubbleProperties</span>(workInProgress);<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="标记更新（放到fiber的updateQueue）"><a href="#标记更新（放到fiber的updateQueue）" class="headerlink" title="标记更新（放到fiber的updateQueue）"></a>标记更新（放到fiber的updateQueue）</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1. 对比新老props，将更新放到fiber的updateQueue</span><br><span class="hljs-comment"> * 2. 打标签flags Update</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; current 老fiber</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; workInProgress 新fiber</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; type 类型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; newProps 新属性</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateHostComponent</span>(<span class="hljs-params">current, workInProgress, type, newProps</span>) &#123;<br>  <span class="hljs-keyword">const</span> oldProps = current.<span class="hljs-property">memoizedProps</span>; <span class="hljs-comment">// 老的属性</span><br>  <span class="hljs-keyword">const</span> instance = workInProgress.<span class="hljs-property">stateNode</span>; <span class="hljs-comment">// 老的dom</span><br><br>  <span class="hljs-comment">// 比较新老属性，产生update, update是二元组的数组 属性，值，属性，值</span><br>  <span class="hljs-keyword">const</span> updatePayload = <span class="hljs-title function_">prepareUpdate</span>(instance, type, oldProps, newProps);<br>  workInProgress.<span class="hljs-property">updateQueue</span> = updatePayload;<br>  <span class="hljs-keyword">if</span> (updatePayload) &#123;<br>    <span class="hljs-title function_">markUpdate</span>(workInProgress);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">prepareUpdate</span>(<span class="hljs-params">domElement, type, oldProps, newProps</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">diffProperties</span>(domElement, type, oldProps, newProps);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">domElement</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">type</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">oldProps</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">newProps</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">diffProperties</span>(<span class="hljs-params">domElement, type, oldProps, newProps</span>) &#123;<br>  <span class="hljs-keyword">let</span> updatePayload = [];<br>  <span class="hljs-keyword">let</span> styleUpdates = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 处理删除属性。如果属性老的有，新的没有，要删除</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> propKey <span class="hljs-keyword">in</span> oldProps) &#123;<br>    <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">STYLE</span>) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 新的有 或 老的没有 跳过</span><br>    <span class="hljs-keyword">if</span> (<br>      newProps.<span class="hljs-title function_">hasOwnProperty</span>(propKey) ||<br>      !oldProps.<span class="hljs-title function_">hasOwnProperty</span>(propKey) ||<br>      oldProps[propKey] === <span class="hljs-literal">null</span><br>    ) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 属性，值，二元组update  删除属性</span><br>    updatePayload.<span class="hljs-title function_">push</span>(propKey, <span class="hljs-literal">null</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 处理更新属性</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> propKey <span class="hljs-keyword">in</span> newProps) &#123;<br>    <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">STYLE</span>) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> newProp = newProps[propKey];<br>    <span class="hljs-keyword">const</span> oldProp = oldProps[propKey] === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : oldProps[propKey];<br>    <span class="hljs-keyword">if</span> (<br>      !newProps.<span class="hljs-title function_">hasOwnProperty</span>(propKey) ||<br>      newProp === <span class="hljs-literal">null</span> ||<br>      oldProp === <span class="hljs-literal">null</span> ||<br>      newProp === oldProp<br>    ) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">CHILDERN</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newProp === <span class="hljs-string">&quot;string&quot;</span> || <span class="hljs-keyword">typeof</span> newProp === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>        updatePayload.<span class="hljs-title function_">push</span>(propKey, newProp);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 更新</span><br>      updatePayload.<span class="hljs-title function_">push</span>(propKey, newProp);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> oldStyle = oldProps[<span class="hljs-variable constant_">STYLE</span>];<br>  <span class="hljs-keyword">const</span> newStyle = newProps[<span class="hljs-variable constant_">STYLE</span>];<br><br>  <span class="hljs-keyword">if</span> (oldStyle || newStyle) &#123;<br>    <span class="hljs-comment">// 样式删除</span><br>    <span class="hljs-keyword">if</span> (oldStyle) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> styleName <span class="hljs-keyword">in</span> oldStyle) &#123;<br>        <span class="hljs-keyword">if</span> (<br>          oldStyle.<span class="hljs-title function_">hasOwnProperty</span>(styleName) &amp;&amp;<br>          (!newStyle || !newStyle.<span class="hljs-title function_">hasOwnProperty</span>(styleName))<br>        ) &#123;<br>          <span class="hljs-keyword">if</span> (!styleUpdates) &#123;<br>            styleUpdates = &#123;&#125;;<br>          &#125;<br>          styleUpdates[styleName] = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 样式更新</span><br>    <span class="hljs-keyword">if</span> (newStyle) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> styleName <span class="hljs-keyword">in</span> newStyle) &#123;<br>        <span class="hljs-keyword">if</span> (<br>          newStyle.<span class="hljs-title function_">hasOwnProperty</span>(styleName) &amp;&amp;<br>          (!oldStyle || oldStyle[styleName] !== newStyle[styleName])<br>        ) &#123;<br>          <span class="hljs-keyword">if</span> (!styleUpdates) &#123;<br>            styleUpdates = &#123;&#125;;<br>          &#125;<br>          styleUpdates[styleName] = newStyle[styleName];<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (styleUpdates) &#123;<br>      updatePayload.<span class="hljs-title function_">push</span>(<span class="hljs-variable constant_">STYLE</span>, styleUpdates);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> updatePayload.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : updatePayload;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>react源码学习-jsx</title>
    <url>/posts/5b77d16c.html</url>
    <content><![CDATA[<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>babel 将jsx转化为jsxDEV函数调用，转换后已经包含了组件元素所有属性，并且嵌套元素组件也转化为嵌套函数调用了<br>定义jsxDEV函数，接收babel转化出来的组件dom数据转化为jsx element(虚拟dom)</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ReactElement</span>(<span class="hljs-params">type, key, ref, props</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">$$typeof</span>: <span class="hljs-variable constant_">REACT_ELEMENT_TYPE</span>, <span class="hljs-comment">// jsx element标识</span><br>    type, <span class="hljs-comment">// span h1 标签</span><br>    key,<br>    ref,<br>    props,<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将babel编译结果转化为jsx element(虚拟dom)</span><br><span class="hljs-comment"> * key, ref, style, children等在babel中都转出来了, 放在了config</span><br><span class="hljs-comment"> * jsx编译后，形成jsxDEV嵌套调用的函数执行，会先执行最内部的element构建</span><br><span class="hljs-comment"> * key, ref 单独存变量，其他存入props</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">type</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">config</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; maybeKey 组件key</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">jsxDEV</span>(<span class="hljs-params">type, config, maybeKey</span>) &#123;<br>  <span class="hljs-keyword">const</span> props = &#123;&#125;;<br>  <span class="hljs-keyword">let</span> key = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> ref = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// key ref存储</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> maybeKey !== <span class="hljs-literal">undefined</span>) &#123;<br>    key = maybeKey;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasValidRef</span>(config)) &#123;<br>    ref = config.<span class="hljs-property">ref</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// props存储</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> propName <span class="hljs-keyword">in</span> config) &#123;<br>    <span class="hljs-keyword">if</span> (<br>      hasOwnProperty.<span class="hljs-title function_">call</span>(config, propName) &amp;&amp;<br>      !<span class="hljs-variable constant_">RESERVED_PROPS</span>.<span class="hljs-title function_">hasOwnProperty</span>(propName)<br>    ) &#123;<br>      props[propName] = config[propName];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReactElement</span>(type, key, ref, props);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>react源码学习-scheduler</title>
    <url>/posts/78409aac.html</url>
    <content><![CDATA[<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>将performConcurrentWorkOnRoot单个fiber的diff任务放到最小堆里<br>通过MessageChannel在下次宏任务时执行workLoop，workLoop就是不断从最小堆取任务执行，直到5ms时间片不够了或者最小堆空了</p>
<p>useEffect的任务也放在最小堆里，优先级是NormalSchedulerPriority</p>
<ol>
<li>ImmediateSchedulerPriority<br>ImmediateSchedulerPriority 调度级别是最高优先级的调度级别，表示更新任务应该立即执行，而不应该等待浏览器空闲。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commitRoot</span>(<span class="hljs-params">root</span>) &#123;<br>  <span class="hljs-keyword">const</span> previousUpdatePriority = <span class="hljs-title function_">getCurrentUpdatePriority</span>();<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// render阶段可以同步或可暂停的，commit阶段必须同步DiscreteEventPriority</span><br>    <span class="hljs-title function_">setCurrentUpdatePriority</span>(<span class="hljs-title class_">DiscreteEventPriority</span>);<br>    <span class="hljs-title function_">commitRootImpl</span>(root);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-title function_">setCurrentUpdatePriority</span>(previousUpdatePriority);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<ol start="2">
<li>UserBlockingSchedulerPriority<br>UserBlockingSchedulerPriority 调度级别表示更新任务是由用户输入触发的，例如点击按钮或输入文本。这些更新任务应该在浏览器空闲时尽快执行，但不应该阻止用户输入响应。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>&#125;<br><br><span class="hljs-keyword">return</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>);<br><br></code></pre></td></tr></table></figure>
<ol start="3">
<li>NormalSchedulerPriority<br>NormalSchedulerPriority 调度级别是默认的调度级别，表示更新任务是由 React 内部触发的，例如在 useEffect() 钩子函数中更新状态。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>&#125;, []);<br><br></code></pre></td></tr></table></figure>
<ol start="4">
<li>IdleSchedulerPriority<br>IdleSchedulerPriority 调度级别是最低优先级的调度级别，表示更新任务是由浏览器空闲时触发的。这些更新任务应该在浏览器空闲时执行，但可以等待更长的时间，以便将多个更新任务合并为一个。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">requestIdleCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>  &#125;);<br>&#125;, []);<br><br></code></pre></td></tr></table></figure>

<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 替代requestIdleCallback</span><br><span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();<br><span class="hljs-keyword">var</span> port2 = channel.<span class="hljs-property">port2</span>;<br><span class="hljs-keyword">var</span> port1 = channel.<span class="hljs-property">port1</span>;<br><br><span class="hljs-comment">// 下一个宏任务执行</span><br>port1.<span class="hljs-property">onmessage</span> = performWorkUntilDeadline;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 按优先级执行任务</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">callback</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-params">priorityLevel, callback</span>) &#123;<br>  <span class="hljs-comment">// requestIdleCallback(callback);</span><br>  <span class="hljs-comment">// 获取当前时间戳</span><br>  <span class="hljs-keyword">const</span> currentTime = <span class="hljs-title function_">getCurrentTime</span>();<br>  <span class="hljs-comment">// 任务开始时间</span><br>  <span class="hljs-keyword">const</span> startTime = currentTime;<br>  <span class="hljs-comment">// 超时时间</span><br>  <span class="hljs-keyword">let</span> timeout;<br>  <span class="hljs-keyword">switch</span> (priorityLevel) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ImmediatePriority</span>:<br>      timeout = <span class="hljs-variable constant_">IMMEDIATE_PRIORITY_TIMEOUT</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">UserBlockingPriority</span>:<br>      timeout = <span class="hljs-variable constant_">USER_BLOCKING_PRIORITY_TIMEOUT</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">IdlePriority</span>:<br>      timeout = <span class="hljs-variable constant_">IDLE_PRIORITY_TIMEOUT</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">LowPriority</span>:<br>      timeout = <span class="hljs-variable constant_">LOW_PRIORITY_TIMEOUT</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">NormalPriority</span>:<br>    <span class="hljs-attr">default</span>:<br>      timeout = <span class="hljs-variable constant_">NORMAL_PRIORITY_TIMEOUT</span>;<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 计算此任务的过期时间</span><br>  <span class="hljs-keyword">const</span> expirationTime = startTime + timeout;<br>  <span class="hljs-keyword">const</span> newTask = &#123;<br>    <span class="hljs-attr">id</span>: taskIdCounter++,<br>    callback, <span class="hljs-comment">// 任务的回调函数</span><br>    priorityLevel, <span class="hljs-comment">// 任务优先级</span><br>    startTime, <span class="hljs-comment">// 任务开始时间</span><br>    expirationTime, <span class="hljs-comment">// 任务的过期时间</span><br>    <span class="hljs-attr">sortIndex</span>: expirationTime, <span class="hljs-comment">// 排序index</span><br>  &#125;;<br><br>  <span class="hljs-comment">// 将任务放入最小堆</span><br>  <span class="hljs-title function_">push</span>(taskQueue, newTask);<br>  <span class="hljs-comment">// 执行任务</span><br>  <span class="hljs-title function_">requestHostCallback</span>(flushWork);<br>  <span class="hljs-keyword">return</span> newTask;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 执行任务队列的任务 最小堆(优先级任务队列)taskQueue</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">startTime</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushWork</span>(<span class="hljs-params">startTime</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">workLoop</span>(startTime);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoop</span>(<span class="hljs-params">startTime</span>) &#123;<br>  <span class="hljs-keyword">let</span> currentTime = startTime;<br>  <span class="hljs-comment">// 取出优先级最高的任务</span><br>  <span class="hljs-keyword">let</span> currentTask = <span class="hljs-title function_">peek</span>(taskQueue);<br><br>  <span class="hljs-keyword">while</span> (currentTask !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 如果当前任务没过期，还要执行，但是没有时间了</span><br>    <span class="hljs-keyword">if</span> (currentTask.<span class="hljs-property">expirationTime</span> &gt; currentTime &amp;&amp; <span class="hljs-title function_">shouldYieldToHost</span>()) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Scheduler:: current schedule is break&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>      <span class="hljs-string">&quot;Scheduler:: handle schedule task&quot;</span>,<br>      currentTask,<br>      currentTask.<span class="hljs-property">callback</span> ? currentTask.<span class="hljs-property">callback</span>.<span class="hljs-property">name</span> : <span class="hljs-literal">null</span><br>    );<br><br>    <span class="hljs-comment">// 取出当前的任务中的回调函数 performConcurrentWorkOnRoot</span><br>    <span class="hljs-keyword">const</span> callback = currentTask.<span class="hljs-property">callback</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-keyword">const</span> didUserCallbackTimeout = currentTask.<span class="hljs-property">expirationTime</span> &lt;= currentTime;<br>      currentTask.<span class="hljs-property">callback</span> = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">const</span> continuationCallback = <span class="hljs-title function_">callback</span>(didUserCallbackTimeout);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Scheduler:: task time cost&quot;</span>, <span class="hljs-title function_">getCurrentTime</span>() - currentTime);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> continuationCallback === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-comment">// 执行任务产生了一个新任务</span><br>        currentTask.<span class="hljs-property">callback</span> = continuationCallback;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Scheduler:: end===========&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 还有任务执行</span><br>      &#125;<br>      <span class="hljs-comment">// 弹出最高优先级任务</span><br>      <span class="hljs-title function_">pop</span>(taskQueue);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 弹出最高优先级任务</span><br>      <span class="hljs-title function_">pop</span>(taskQueue);<br>    &#125;<br>    currentTask = <span class="hljs-title function_">peek</span>(taskQueue);<br>  &#125;<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Scheduler:: end===========&quot;</span>);<br>  <span class="hljs-comment">// 还有任务</span><br>  <span class="hljs-keyword">if</span> (currentTask !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// 如果任务队列所有任务都执行完了，没有下一个任务</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 最小堆 这一次循环执行是否超过5ms</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldYieldToHost</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> timeElapsed = <span class="hljs-title function_">getCurrentTime</span>() - startTime;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Scheduler:: timeElapsed&quot;</span>, timeElapsed);<br>  <span class="hljs-keyword">if</span> (timeElapsed &lt; frameInterval) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">requestHostCallback</span>(<span class="hljs-params">flushWork</span>) &#123;<br>  <span class="hljs-comment">// 先缓存工作循环 执行函数</span><br>  scheduleHostCallback = flushWork;<br>  <span class="hljs-comment">// 产生一个宏任务，执行最小堆 scheduleHostCallback/flushWork/workLoop</span><br>  <span class="hljs-title function_">schedulePerformWorkUntilDeadline</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">schedulePerformWorkUntilDeadline</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 下个宏任务执行performWorkUntilDeadline</span><br>  port2.<span class="hljs-title function_">postMessage</span>(<span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">performWorkUntilDeadline</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>    <span class="hljs-string">&quot;Scheduler:: schedule start===========. min heap size&quot;</span>,<br>    taskQueue.<span class="hljs-property">length</span><br>  );<br>  <span class="hljs-keyword">if</span> (scheduleHostCallback) &#123;<br>    <span class="hljs-comment">// workLoop</span><br>    <span class="hljs-comment">// 先获取开始执行任务的时间</span><br>    startTime = <span class="hljs-title function_">getCurrentTime</span>();<br>    <span class="hljs-comment">// 是否有更多的工作</span><br>    <span class="hljs-keyword">let</span> hasMoreWork = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 执行超过5ms，还有任务 或者 最小堆里任务执行完了</span><br>      hasMoreWork = <span class="hljs-title function_">scheduleHostCallback</span>(startTime);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// 如果时间超过5ms, 还有任务，产生一个宏任务，下次继续，此时浏览器可以接手执行渲染dom 或者 不执行</span><br>      <span class="hljs-keyword">if</span> (hasMoreWork) &#123;<br>        <span class="hljs-title function_">schedulePerformWorkUntilDeadline</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 清空任务队列执行函数</span><br>        scheduleHostCallback = <span class="hljs-literal">null</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="render-优先级转换"><a href="#render-优先级转换" class="headerlink" title="render 优先级转换"></a>render 优先级转换</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * lane优先级转事件优先级</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 将lane优先级转eventPriority</span><br><span class="hljs-comment"> * 将31收敛到4个</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 落入eventPriority数轴区间里，则返回右侧eventPriority</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * eventPriority 数轴  lane 1 lane 4  lane 16 lane 536870912</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">lanes</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">lanesToEventPriority</span>(<span class="hljs-params">lanes</span>) &#123;<br>  <span class="hljs-comment">// 获取最高优先级的lane</span><br>  <span class="hljs-keyword">let</span> lane = <span class="hljs-title function_">getHeighestPriorityLane</span>(lanes);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isHeigherEventPriority</span>(<span class="hljs-title class_">DiscreteEventPriority</span>, lane)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">DiscreteEventPriority</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isHeigherEventPriority</span>(<span class="hljs-title class_">ContinuousEventPriority</span>, lane)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ContinuousEventPriority</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">includesNonIdleWork</span>(lane)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">DefaultEventPriority</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">IdleEventPriority</span>;<br>&#125;<br><span class="hljs-comment">// 事件优先级转5个调度优先级</span><br> <span class="hljs-keyword">switch</span> (<span class="hljs-title function_">lanesToEventPriority</span>(nextLanes)) &#123;<br>      <span class="hljs-comment">// lane转eventPriority, eventPriority转schedulerPriorityLevel</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-title class_">DiscreteEventPriority</span>:<br>        schedulerPriorityLevel = <span class="hljs-title class_">ImmediateSchedulerPriority</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ContinuousEventPriority</span>:<br>        schedulerPriorityLevel = <span class="hljs-title class_">UserBlockingSchedulerPriority</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-title class_">DefaultEventPriority</span>:<br>        schedulerPriorityLevel = <span class="hljs-title class_">NormalSchedulerPriority</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IdleEventPriority</span>:<br>        schedulerPriorityLevel = <span class="hljs-title class_">IdleSchedulerPriority</span>;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-attr">default</span>:<br>        schedulerPriorityLevel = <span class="hljs-title class_">NormalSchedulerPriority</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>react源码学习-useState</title>
    <url>/posts/b25a71c7.html</url>
    <content><![CDATA[<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>fiber.memoizedState 保存的是hook链表<br>hook.queue.pending 保存的是这个hook的更新链表，更新就是reducer的入参action, 例如：{type: ‘add’, payload: 1}</p>
<p>setState</p>
<ol>
<li>执行 dispatchReducerAction &#x3D;&gt; 将update暂存到concurrentQueues</li>
<li>scheduleUpdateOnFiber root上执行更新&#x3D;&gt; performConcurrentWorkOnRoot &#x3D;&gt; renderRootConCurrent<br>a) &#x3D;&gt; prepareFreshStack 将concurrentQueuesupdate 里的update挂载到对应hook的queue<br>b) &#x3D;&gt; workLoopConcurrent &#x3D;&gt; performUnitOfWork &#x3D;&gt; beginWork beginWork里的过程，renderWithHooks &#x3D;&gt; 执行Component组件函数 &#x3D;&gt; 执行useState &#x3D;&gt; 执行updateReducer(执行hook.queue, 执行state更新，影响了渲染数据jsx element) &#x3D;&gt; dom-diff打标记</li>
</ol>
<h3 id="setState-执行"><a href="#setState-执行" class="headerlink" title="setState 执行"></a>setState 执行</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * setState 函数</span><br><span class="hljs-comment"> * 将update三元组缓存下来。renderRootSync时，将update放到hook的更新队列queue</span><br><span class="hljs-comment"> * 调度重新渲染</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">fiber</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">queue</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">action</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchReducerAction</span>(<span class="hljs-params">fiber, queue, action</span>) &#123;<br>  <span class="hljs-comment">// 获取当前的更新赛道</span><br>  <span class="hljs-keyword">const</span> lane = <span class="hljs-title function_">requestUpdateLane</span>();<br>  <span class="hljs-keyword">const</span> update = &#123;<br>    action, <span class="hljs-comment">// &#123;type: &#x27;add&#x27;, payload: 1&#125;</span><br>    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,<br>  &#125;;<br>  <span class="hljs-comment">// 把当前更新放到更新队列里，并返回根fiber</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;set State reducer&quot;</span>);<br>  <span class="hljs-keyword">const</span> root = <span class="hljs-title function_">enqueueConcurrentHookUpdate</span>(fiber, queue, update, lane);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;scheduleUpdateOnFiber&quot;</span>);<br>  <span class="hljs-keyword">const</span> eventTime = <span class="hljs-title function_">requestEventTime</span>();<br>  <span class="hljs-comment">// root上执行更新  render阶段+commit阶段</span><br>  <span class="hljs-title function_">scheduleUpdateOnFiber</span>(root, fiber, lane, eventTime);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="useState执行（updateReducer执行）"><a href="#useState执行（updateReducer执行）" class="headerlink" title="useState执行（updateReducer执行）"></a>useState执行（updateReducer执行）</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// useState其实就是内置了reducer的useReducer</span><br><span class="hljs-comment">// action 就是setState的入参，(oldState)=&gt; newState 或者state</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">baseStateReducer</span>(<span class="hljs-params">state, action</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> action === <span class="hljs-string">&quot;function&quot;</span> ? <span class="hljs-title function_">action</span>(state) : action;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateState</span>(<span class="hljs-params">initialState</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateReducer</span>(baseStateReducer);<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 组件useReducer的底层函数</span><br><span class="hljs-comment"> * 1. 复制老hook 到新hook (所以没有执行setState, state对象连地址都不变)</span><br><span class="hljs-comment"> * 2. 执行reducer, 更新state</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">reducer</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> [新state, setState]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateReducer</span>(<span class="hljs-params">reducer</span>) &#123;<br>  <span class="hljs-comment">// 新hook</span><br>  <span class="hljs-keyword">const</span> hook = <span class="hljs-title function_">updateWorkInProgressHook</span>();<br>  <span class="hljs-comment">// 新的更新队列</span><br>  <span class="hljs-keyword">const</span> queue = hook.<span class="hljs-property">queue</span>;<br>  <span class="hljs-comment">// 老的hook</span><br>  <span class="hljs-keyword">const</span> current = currentHook;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;执行hook更新队列hook.queue，更新state&quot;</span>, queue);<br><br>  queue.<span class="hljs-property">lastRenderedReducer</span> = reducer;<br>  <span class="hljs-keyword">let</span> baseQueue = current.<span class="hljs-property">baseQueue</span>;<br>  <span class="hljs-comment">// 基于老state, 执行reducer，计算newState</span><br><br>  <span class="hljs-comment">// 合并新旧update链表， pendingQueue baseQueue都是循环链表，指向链表末尾</span><br>  <span class="hljs-keyword">const</span> pendingQueue = queue.<span class="hljs-property">pending</span>;<br>  <span class="hljs-keyword">if</span> (pendingQueue !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (baseQueue !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">const</span> baseFirst = baseQueue.<span class="hljs-property">next</span>;<br>      <span class="hljs-keyword">const</span> pendingFirst = pendingQueue.<span class="hljs-property">next</span>;<br>      baseQueue.<span class="hljs-property">next</span> = pendingFirst;<br>      pendingQueue.<span class="hljs-property">next</span> = baseFirst;<br>    &#125;<br>    current.<span class="hljs-property">baseQueue</span> = baseQueue = pendingQueue;<br>    queue.<span class="hljs-property">pending</span> = <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 执行update链表</span><br>  <span class="hljs-keyword">if</span> (baseQueue !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> first = baseQueue.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">let</span> newState = current.<span class="hljs-property">baseState</span>;<br>    <span class="hljs-keyword">let</span> newBaseState = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> newBaseQueueFirst = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> newBaseQueueLast = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> update = first;<br>    <span class="hljs-keyword">do</span> &#123;<br>      <span class="hljs-keyword">const</span> updateLane = update.<span class="hljs-property">lane</span>;<br>      <span class="hljs-keyword">const</span> shouldSkipUpdate = !<span class="hljs-title function_">isSubsetOfLanes</span>(renderLanes, updateLane);<br>      <span class="hljs-keyword">if</span> (shouldSkipUpdate) &#123;<br>        <span class="hljs-comment">// 如果优先级不够跳过更新</span><br>        <span class="hljs-keyword">const</span> clone = &#123;<br>          <span class="hljs-attr">lane</span>: updateLane,<br>          <span class="hljs-attr">action</span>: update.<span class="hljs-property">action</span>,<br>          <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,<br>        &#125;;<br>        <span class="hljs-comment">// 将update复制到baseQueue里</span><br>        <span class="hljs-keyword">if</span> (newBaseQueueLast === <span class="hljs-literal">null</span>) &#123;<br>          newBaseQueueFirst = newBaseQueueLast = clone;<br>          newBaseState = newState;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          newBaseQueueLast = newBaseQueueLast.<span class="hljs-property">next</span> = clone;<br>        &#125;<br>        <span class="hljs-comment">// lane也复制到fiber里</span><br>        currentlyRenderingFiber.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanes</span>(<br>          currentlyRenderingFiber.<span class="hljs-property">lanes</span>,<br>          updateLane<br>        );<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 优先级够，执行update</span><br>        <span class="hljs-comment">// 如果在跳过update之后的update, 由于state顺序执行，所有下次还要执行，复制到新baseQueue</span><br>        <span class="hljs-keyword">if</span> (newBaseQueueLast !== <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">const</span> clone = &#123;<br>            <span class="hljs-attr">lane</span>: <span class="hljs-title class_">NoLane</span>,<br>            <span class="hljs-attr">action</span>: update.<span class="hljs-property">action</span>,<br>            <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,<br>          &#125;;<br>          newBaseQueueLast = newBaseQueueLast.<span class="hljs-property">next</span> = clone;<br>        &#125;<br>        <span class="hljs-keyword">const</span> action = update.<span class="hljs-property">action</span>;<br>        <span class="hljs-comment">// 执行更新</span><br>        newState = <span class="hljs-title function_">reducer</span>(newState, action);<br>      &#125;<br>      update = update.<span class="hljs-property">next</span>;<br>    &#125; <span class="hljs-keyword">while</span> (update !== <span class="hljs-literal">null</span> &amp;&amp; update !== first);<br><br>    <span class="hljs-keyword">if</span> (newBaseQueueLast === <span class="hljs-literal">null</span>) &#123;<br>      newBaseState = newState;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      newBaseQueueLast.<span class="hljs-property">next</span> = newBaseQueueFirst;<br>    &#125;<br>    hook.<span class="hljs-property">memoizedState</span> = newState;<br>    hook.<span class="hljs-property">baseState</span> = newBaseState;<br>    hook.<span class="hljs-property">baseQueue</span> = newBaseQueueLast;<br>    queue.<span class="hljs-property">lastRenderedState</span> = newState;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (baseQueue === <span class="hljs-literal">null</span>) &#123;<br>    queue.<span class="hljs-property">lanes</span> = <span class="hljs-title class_">NoLanes</span>;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hook.<span class="hljs-property">memoizedState</span>, <span class="hljs-string">&quot;====-----------------&quot;</span>);<br><br>  <span class="hljs-keyword">return</span> [hook.<span class="hljs-property">memoizedState</span>, queue.<span class="hljs-property">dispatch</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>react源码学习-合成事件</title>
    <url>/posts/25bfce3c.html</url>
    <content><![CDATA[<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>事件委托在容器dom</p>
<p>触发容器dom事件时，</p>
<ol>
<li>先从e中获取事件源dom, 再从缓存中拿dom的fiber，再从该fiber到根fiber拉一遍回调函数</li>
<li>创建合成事件对象：{click: 回调数组}</li>
<li>从合成事件里拿回调函数执行</li>
</ol>
<h3 id="事件委托执行的函数"><a href="#事件委托执行的函数" class="headerlink" title="事件委托执行的函数"></a>事件委托执行的函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这个函数就是委托函数，addEventListner click</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchEventForPlugins</span>(<span class="hljs-params"></span><br><span class="hljs-params">  domEventName, <span class="hljs-comment">// click</span></span><br><span class="hljs-params">  eventSystemFlags, <span class="hljs-comment">// 阶段 冒泡0 捕获4</span></span><br><span class="hljs-params">  nativeEvent, <span class="hljs-comment">// 事件e</span></span><br><span class="hljs-params">  targetInst, <span class="hljs-comment">//  事件源dom对应fiber</span></span><br><span class="hljs-params">  targetContainer <span class="hljs-comment">// 容器dom</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> nativeEventTarget = <span class="hljs-title function_">getEventTarget</span>(nativeEvent);<br>  <span class="hljs-keyword">const</span> dispatchQueue = [];<br><br>  <span class="hljs-comment">// 将合成事件和执行函数 zip组合 放入dispatchQueue</span><br>  <span class="hljs-title function_">extractEvents</span>(<br>    dispatchQueue,<br>    domEventName,<br>    targetInst,<br>    nativeEvent,<br>    nativeEventTarget,<br>    eventSystemFlags,<br>    targetContainer<br>  );<br>  <span class="hljs-comment">// 执行所有dispatchQueue, 所有click的react事件回调</span><br>  <span class="hljs-title function_">processDispatchQueue</span>(dispatchQueue, eventSystemFlags);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="从目标fiber到根fiber累积触发的合成事件回调"><a href="#从目标fiber到根fiber累积触发的合成事件回调" class="headerlink" title="从目标fiber到根fiber累积触发的合成事件回调"></a>从目标fiber到根fiber累积触发的合成事件回调</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把要执行的回调函数添加到dispatchQueue</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; dispatchQueue 事件函数队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; domEventName dom事件名 click</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; targetInst  事件源dom对应fiber</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; nativeEvent 原生事件 e</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; nativeEventTarget 事件源dom</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; eventSystemFlags 冒泡0，捕获4</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; targetContainer 容器dom div#root</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">extractEvents</span>(<span class="hljs-params"></span><br><span class="hljs-params">  dispatchQueue,</span><br><span class="hljs-params">  domEventName,</span><br><span class="hljs-params">  targetInst,</span><br><span class="hljs-params">  nativeEvent,</span><br><span class="hljs-params">  nativeEventTarget,</span><br><span class="hljs-params">  eventSystemFlags,</span><br><span class="hljs-params">  targetContainer</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-title class_">SyntheticEventCtor</span>; <span class="hljs-comment">// 合成事件的构建函数</span><br>  <span class="hljs-keyword">switch</span> (domEventName) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;click&quot;</span>:<br>      <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticMouseEvent</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> reactName = topLevelEventsToReactNames.<span class="hljs-title function_">get</span>(domEventName); <span class="hljs-comment">// click=&gt; onClick</span><br>  <span class="hljs-keyword">const</span> isCapturePhase = (eventSystemFlags &amp; <span class="hljs-variable constant_">IS_CAPTURE_PHASE</span>) !== <span class="hljs-number">0</span>; <span class="hljs-comment">// 是否捕获阶段</span><br><br>  <span class="hljs-comment">// 从fiber到根fiber 累计react事件函数</span><br>  <span class="hljs-keyword">const</span> listeners = <span class="hljs-title function_">accumulateSinglePhaseListeners</span>(<br>    targetInst,<br>    reactName,<br>    nativeEvent.<span class="hljs-property">type</span>,<br>    isCapturePhase<br>  );<br><br>  <span class="hljs-keyword">if</span> (listeners.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntheticEventCtor</span>(<br>      reactName,<br>      domEventName,<br>      <span class="hljs-literal">null</span>,<br>      nativeEvent,<br>      nativeEventTarget<br>    );<br><br>    dispatchQueue.<span class="hljs-title function_">push</span>(&#123;<br>      event, <span class="hljs-comment">// 合成事件实例</span><br>      listeners, <span class="hljs-comment">// 执行函数组</span><br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从fiber到根fiber 累计react事件函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; targetFiber fiber</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; reactName react事件名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">nativeEventType</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; isCapturePhase 是不是捕获阶段</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">accumulateSinglePhaseListeners</span>(<span class="hljs-params"></span><br><span class="hljs-params">  targetFiber,</span><br><span class="hljs-params">  reactName,</span><br><span class="hljs-params">  nativeEventType,</span><br><span class="hljs-params">  isCapturePhase</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> captureName = reactName + <span class="hljs-string">&quot;Capture&quot;</span>;<br>  <span class="hljs-keyword">const</span> reactEventName = isCapturePhase ? captureName : reactName;<br>  <span class="hljs-keyword">const</span> listeners = [];<br>  <span class="hljs-keyword">let</span> instance = targetFiber;<br>  <span class="hljs-keyword">while</span> (instance !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; stateNode, tag &#125; = instance;<br>    <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">HostComponent</span> &amp;&amp; stateNode !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">const</span> listener = <span class="hljs-title function_">getListener</span>(instance, reactEventName);<br>      <span class="hljs-keyword">if</span> (listener) &#123;<br>        listeners.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createDispatchListener</span>(instance, listener, stateNode));<br>      &#125;<br>    &#125;<br>    instance = instance.<span class="hljs-property">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> listeners;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="执行合成事件"><a href="#执行合成事件" class="headerlink" title="执行合成事件"></a>执行合成事件</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 执行合成事件 dispatchQueue</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; dispatchQueue &#123;event 合成事件, listeners react事件函数&#125; 数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; eventSystemFlags 是否捕获阶段</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processDispatchQueue</span>(<span class="hljs-params">dispatchQueue, eventSystemFlags</span>) &#123;<br>  <span class="hljs-comment">// 判断是否在捕获阶段</span><br>  <span class="hljs-keyword">const</span> isCapturePhase = (eventSystemFlags &amp; <span class="hljs-variable constant_">IS_CAPTURE_PHASE</span>) !== <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dispatchQueue.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> &#123; event, listeners &#125; = dispatchQueue[i];<br>    <span class="hljs-title function_">processDispatchQueueItemsInOrder</span>(event, listeners, isCapturePhase);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 执行react事件函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; event 合成事件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; dispatchListeners 合成事件函数 和附带的fiber和dom</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; isCapturePhase 是否捕获阶段</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processDispatchQueueItemsInOrder</span>(<span class="hljs-params"></span><br><span class="hljs-params">  event,</span><br><span class="hljs-params">  dispatchListeners,</span><br><span class="hljs-params">  isCapturePhase</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (isCapturePhase) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = dispatchListeners.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-keyword">const</span> &#123; listener, currentTarget &#125; = dispatchListeners[i]; <span class="hljs-comment">// listener onClick, currentTarget dom, instance fiber</span><br>      <span class="hljs-keyword">if</span> (event.<span class="hljs-title function_">isPropagationStopped</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-title function_">executeDispatch</span>(event, listener, currentTarget);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dispatchListeners.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">const</span> &#123; listener, currentTarget &#125; = dispatchListeners[i]; <span class="hljs-comment">// react的onClick函数</span><br>      <span class="hljs-keyword">if</span> (event.<span class="hljs-title function_">isPropagationStopped</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-title function_">executeDispatch</span>(event, listener, currentTarget);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>react源码学习-根fiber</title>
    <url>/posts/f57ca763.html</url>
    <content><![CDATA[<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>fiber 双缓存架构，根fiber(HostRootFiber)有2个，互为主备<br>容器root节点(FiberRootNode)的current指向旧的根fiber，也就是显示在界面上的fiber树对应的根fiber</p>
<p>FiberRootNode.current指向HostRootFiber<br>HostRootFiber.stateNode指向FiberRootNode<br>FiberRootNode.containerInfo是容器dom</p>
<h3 id="创建FiberRootNode"><a href="#创建FiberRootNode" class="headerlink" title="创建FiberRootNode"></a>创建FiberRootNode</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">FiberRootNode</span>(<span class="hljs-params">containerInfo</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">containerInfo</span> = containerInfo;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建一个根fiber, 并且绑定真实dom</span><br><span class="hljs-comment"> * 根fiber有2个，双缓存</span><br><span class="hljs-comment"> * 容器dom只有一个，绑定在旧fiber树的根fiber</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; containerInfo id为root的真实dom</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> FiberRootNode&#123;containerInfo: root dom&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberRoot</span>(<span class="hljs-params">containerInfo</span>) &#123;<br>  <span class="hljs-comment">// 根fiber的真实dom 容器dom</span><br>  <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FiberRootNode</span>(containerInfo);<br>  <span class="hljs-comment">// 根fiber</span><br>  <span class="hljs-keyword">const</span> uninitializedFiber = <span class="hljs-title function_">createHostRootFiber</span>();<br>  <span class="hljs-comment">// 互相关联</span><br>  root.<span class="hljs-property">current</span> = uninitializedFiber;<br>  uninitializedFiber.<span class="hljs-property">stateNode</span> = root;<br>  <span class="hljs-keyword">return</span> root;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<h3 id="创建HostRootFiber"><a href="#创建HostRootFiber" class="headerlink" title="创建HostRootFiber"></a>创建HostRootFiber</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * fiber数据结构</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; tag fiber类型 函数组件0，类组件1，原生组件5，根fiber3</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; pendingProps 等待处理的属性</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; key 唯一标识</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">FiberNode</span>(<span class="hljs-params">tag, pendingProps, key</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag; <span class="hljs-comment">// 函数组件0，类组件1，原生组件5，根fiber3</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// jsx element(虚拟dom)的type, 例如 span div p func(类组件，函数组件)</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateNode</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// fiber对应真实dom的引用</span><br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">return</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向父fiber</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 指向第一个子fiber</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">//指向下一个兄弟fiber</span><br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingProps</span> = pendingProps; <span class="hljs-comment">// 等待生效的属性</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedProps</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 已经生效的属性</span><br><br>  <span class="hljs-comment">// 存储的数据</span><br>  <span class="hljs-comment">// 类组件 类state</span><br>  <span class="hljs-comment">// 函数组件 hooks</span><br>  <span class="hljs-comment">// 根fiber 要渲染的元素</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 更新操作队列</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 副作用标记，标识这个fiber要进行什么操作</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">flags</span> = <span class="hljs-title class_">NoFlags</span>;<br>  <span class="hljs-comment">// 子节点有没有副作用的标记，冒泡统计，用于性能优化</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">subtreeFlags</span> = <span class="hljs-title class_">NoFlags</span>;<br>  <span class="hljs-comment">// 新旧fiber互相引用</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// dom-diff 移动</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 子fiber删除数组</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">deletions</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 优先级</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lanes</span> = <span class="hljs-title class_">NoLanes</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">ref</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">//子fiber的汇总lane</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">childLanes</span> = <span class="hljs-title class_">NoLanes</span>;<br>&#125;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiber</span>(<span class="hljs-params">tag, pendingProps, key</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FiberNode</span>(tag, pendingProps, key);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createHostRootFiber</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFiber</span>(<span class="hljs-title class_">HostRoot</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>react源码学习-遍历fiber树</title>
    <url>/posts/a73b9890.html</url>
    <content><![CDATA[<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>fiber架构render阶段可以中断，以fiber为单元，一次计算一个fiber。<br>使用深度遍历fiber树，先dfs所有child链表，再走回父节点（左右中）。<br>进入一个节点执行beginWork，没有子节点时完成这个叶子节点，或者子节点都完成走回父节点把父节点完成，执行completeWork。</p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">performUnitOfWork</span>(<span class="hljs-params">unitOfWork</span>) &#123;<br>  <span class="hljs-keyword">const</span> current = unitOfWork.<span class="hljs-property">alternate</span>;<br>  <span class="hljs-keyword">const</span> next = <span class="hljs-title function_">beginWork</span>(current, unitOfWork, workInProgressRootRenderLanes);<br>  unitOfWork.<span class="hljs-property">memoizedProps</span> = unitOfWork.<span class="hljs-property">pendingProps</span>;<br><br>  <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 如果dfs到了叶子节点，没有child, 执行complete</span><br>    <span class="hljs-title function_">completeUnitOfWork</span>(unitOfWork);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    workInProgress = next;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">completeUnitOfWork</span>(<span class="hljs-params">unitOfWork</span>) &#123;<br>  <span class="hljs-keyword">let</span> completedWork = unitOfWork;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">const</span> current = completedWork.<span class="hljs-property">alternate</span>;<br>    <span class="hljs-keyword">const</span> returnFiber = completedWork.<span class="hljs-property">return</span>;<br>    <span class="hljs-title function_">completeWork</span>(current, completedWork);<br><br>    <span class="hljs-keyword">const</span> siblingFiber = completedWork.<span class="hljs-property">sibling</span>;<br>    <span class="hljs-comment">// 先dfs兄弟节点</span><br>    <span class="hljs-keyword">if</span> (siblingFiber !== <span class="hljs-literal">null</span>) &#123;<br>      workInProgress = siblingFiber;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 当前节点是child链表的最后一个，下一个是父节点</span><br>    completedWork = returnFiber;<br>    workInProgress = completedWork;<br>  &#125; <span class="hljs-keyword">while</span> (completedWork !== <span class="hljs-literal">null</span>);<br><br>  <span class="hljs-comment">// 如果走到了这里，说明整个fiber树构建完成，render阶段完成</span><br>  <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === <span class="hljs-title class_">RootInProgress</span>) &#123;<br>    workInProgressRootExitStatus = <span class="hljs-title class_">RootCompleted</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/posts/de0b971c.html</url>
    <content><![CDATA[<h2 id="【译】单例模式singleton-pattern"><a href="#【译】单例模式singleton-pattern" class="headerlink" title="【译】单例模式singleton-pattern"></a>【译】单例模式<a href="https://www.patterns.dev/vanilla/singleton-pattern">singleton-pattern</a></h2><p>单例是只能实例化一次并可以全局访问的类。这个单一实例可以在整个应用程序中共享，使得单例在管理应用程序的全局状态方面非常有用。</p>
<p>首先，让我们看一下使用ES2015类的单例模式的示例。对于这个示例，我们将构建一个Counter类，其中包含：</p>
<ul>
<li>一个getInstance方法，返回实例的值</li>
<li>一个getCount方法，返回计数器变量的当前值</li>
<li>一个increment方法，将计数器的值增加1</li>
<li>一个decrement方法，将计数器的值减少1</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>  <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">getCount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> counter;<br>  &#125;<br><br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ++counter;<br>  &#125;<br><br>  <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> --counter;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然而，这个类不符合单例的标准！一个单例应该只能被实例化一次。目前，我们可以创建多个Counter类的实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> counter1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>();<br><span class="hljs-keyword">const</span> counter2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter1.<span class="hljs-title function_">getInstance</span>() === counter2.<span class="hljs-title function_">getInstance</span>()); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>通过调用new方法两次，我们只是将counter1和counter2设置为不同的实例。在counter1和counter2上调用getInstance方法返回的值实际上是对不同实例的引用：它们并不严格相等！</p>
<p>让我们确保只能创建一个Counter类的实例。</p>
<p>确保只能创建一个实例的一种方法是创建一个名为instance的变量。在Counter的构造函数中，当创建一个新实例时，我们可以将instance设置为对该实例的引用。我们可以通过检查instance变量是否已经有值来阻止新的实例化。如果是这种情况，表示已经存在一个实例。这是不应该发生的：应该抛出错误来通知用户</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> instance;<br><span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (instance) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;You can only create one instance!&quot;</span>);<br>    &#125;<br>    instance = <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">getCount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> counter;<br>  &#125;<br><br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ++counter;<br>  &#125;<br><br>  <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> --counter;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>();<br><span class="hljs-keyword">const</span> counter2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>();<br><span class="hljs-comment">// Error: You can only create one instance!</span><br></code></pre></td></tr></table></figure>

<p>完美！我们不能再创建多个实例了。Reflect也不行。</p>
<p>让我们从counter.js文件中导出Counter实例。但在这样做之前，我们还应该冻结实例。Object.freeze方法确保使用代码无法修改单例。冻结实例上的属性不能添加或修改，这减少了意外覆盖单例值的风险。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> instance;<br><span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (instance) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;You can only create one instance!&quot;</span>);<br>    &#125;<br>    instance = <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">getCount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> counter;<br>  &#125;<br><br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ++counter;<br>  &#125;<br><br>  <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> --counter;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> singletonCounter = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>());<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> singletonCounter;<br></code></pre></td></tr></table></figure>

<h3 id="权衡利弊"><a href="#权衡利弊" class="headerlink" title="权衡利弊"></a>权衡利弊</h3><p>将实例化限制为只有一个实例可能会节省大量的内存空间。不必每次都为新实例设置内存，只需为那个在整个应用程序中引用的实例设置内存。然而，单例实际上被认为是一种反模式，在JavaScript中应该尽量避免使用。</p>
<p>优点：当new一个对象代价很大时，单例可以减少内存占用，网络IO等</p>
<p>缺点：全局状态，修改来源难以确定，容易导致意外的更新</p>
<p>然而，上面示例中的类实现实际上是过度的。由于我们可以直接在JavaScript中创建对象，我们可以简单地使用普通对象来实现完全相同的结果。让我们来看一下使用单例的一些缺点！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">// counter.js</span><br><span class="hljs-keyword">let</span> instance;<br><span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (instance) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Only one instance is allowed!&quot;</span>);<br>    &#125;<br>    instance = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span> = counter;<br>  &#125;<br><br>  <span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">getCount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> counter;<br>  &#125;<br><br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ++counter;<br>  &#125;<br><br>  <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> --counter;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> singletonCounter = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>());<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> singletonCounter;<br><br><span class="hljs-comment">// superCounter.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./counter&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperCounter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>();<br>    <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> += <span class="hljs-number">100</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">decrement</span>();<br>    <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> -= <span class="hljs-number">100</span>);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./styles.css&quot;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./counter&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">SuperCounter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./superCounter&quot;</span>;<br><span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperCounter</span>();<br><br>counter.<span class="hljs-title function_">increment</span>();<br>counter.<span class="hljs-title function_">increment</span>();<br>counter.<span class="hljs-title function_">increment</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Counter in counter.js: &quot;</span>, <span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">getCount</span>());<br><br><span class="hljs-keyword">const</span> rootElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>);<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span>Check the console!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>, rootElement);<br><br><br></code></pre></td></tr></table></figure>

<h3 id="隐藏依赖关系"><a href="#隐藏依赖关系" class="headerlink" title="隐藏依赖关系"></a>隐藏依赖关系</h3><p>在导入另一个模块时，比如superCounter.js，在导入该模块时可能不明显该模块正在导入一个单例。在其他文件中，比如index.js，在导入该模块并调用其方法时，我们可能会意外地修改单例中的值。这可能会导致意外行为，因为多个实例的单例可以在整个应用程序中共享，并且也会被修改。</p>
<h3 id="全局行为"><a href="#全局行为" class="headerlink" title="全局行为"></a>全局行为</h3><p>单例实例应该能够在整个应用程序中被引用。全局变量本质上显示相同的行为：由于全局变量在全局范围内可用，我们可以在整个应用程序中访问这些变量。</p>
<p>拥有全局变量通常被认为是一个糟糕的设计决策。全局作用域污染可能会导致意外覆盖全局变量的值，这可能会导致许多意外行为。</p>
<p>在ES2015中，创建全局变量相当不常见。新的let和const关键字通过将使用这两个关键字声明的变量限定在块级作用域中，防止开发人员意外地污染全局作用域。JavaScript中的新模块系统使得创建全局可访问的值更加容易，而不会污染全局作用域，通过能够从模块中导出值，并在其他文件中导入这些值。</p>
<p>然而，单例的常见用例是在整个应用程序中具有某种全局状态。让代码库的多个部分依赖于同一个可变对象可能会导致意外行为。</p>
<p>通常，代码库的某些部分修改全局状态中的值，而其他部分消费该数据。执行顺序很重要：当还没有数据可供消费时，我们不希望意外地先消费数据！当使用全局状态时，理解数据流程可能会变得非常棘手，特别是当应用程序不断增长，数十个组件相互依赖时。</p>
<h3 id="react全局状态管理"><a href="#react全局状态管理" class="headerlink" title="react全局状态管理"></a>react全局状态管理</h3><p>在React中，我们通常依赖于状态管理工具（如Redux或React Context）来实现全局状态，而不是使用单例。尽管它们的全局状态行为可能与单例类似，但这些工具提供的是只读状态，而不是可变状态。在使用Redux时，只有纯函数reducer可以更新状态，在组件通过调度程序发送操作后。</p>
<p>尽管使用这些工具不能神奇地消除全局状态的缺点，但我们至少可以确保全局状态按照我们的意图进行修改，因为组件无法直接更新状态。</p>
]]></content>
      <categories>
        <category>Patterns</category>
      </categories>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/posts/7b063943.html</url>
    <content><![CDATA[<h2 id="【译】策略模式strategy-pattern"><a href="#【译】策略模式strategy-pattern" class="headerlink" title="【译】策略模式strategy-pattern"></a>【译】策略模式<a href="https://carloscaballero.io/stategy-pattern-in-javascript-typescript/">strategy-pattern</a></h2><p>有23个经典设计模式在原始书籍《设计模式：可复用面向对象软件的元素》中被描述。这些模式提供了解决在软件开发中反复出现特定问题的方案。</p>
<p>在这篇文章中，我将描述策略模式的工作原理，它是如何工作的，以及应该在何时何地应用它。在其他上下文中，这种模式也被称为策略模式。</p>
<h3 id="策略模式：基本思想"><a href="#策略模式：基本思想" class="headerlink" title="策略模式：基本思想"></a>策略模式：基本思想</h3><p>策略模式是一种行为设计模式，它允许在运行时选择算法——维基百科 </p>
<p>定义一系列算法，将每个算法封装起来，并使它们可以互换。 策略模式让算法能够独立于使用它的客户端而变化。——《设计模式：可复用面向对象软件的元素》</p>
<p>这种模式的主要特点是，客户端有一组算法，可以在运行时选择特定的算法来使用。这些算法之间是可以互换的。</p>
<p>以下代码展示了一个经典问题，即你需要在应用程序中选择一个具体的算法。在这个代码中，你使用了任何编程语言中的<code>switch</code>控制结构。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">myMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">switch</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_strategySelected</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleStrategy</span>:<br>            <span class="hljs-title class_">ComposeWithSimpleStrategy</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-title class_">TeXStrategy</span>:<br>            <span class="hljs-title class_">ComposeWithTeXStrategy</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><span class="hljs-comment">// merge results with existing composition, if necessary</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>然而，使用策略模式可以更加灵活，它将具有以下结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">myMethod</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_strategySelected</span>-&gt;<span class="hljs-title class_">Compose</span>();<br>  <span class="hljs-comment">// merge results with existing composition, if necessary</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种模式的UML图如下所示：</p>
<p><img src="/pic/strategy-pattern.png" alt="strategy-pattern-uml"></p>
<p>每种策略都通过一个具体的对象来表示。因此，context包含一个策略对象（具体策略A、具体策略B等），该对象实现了策略接口。策略之间互换的关键在于在context实现一个方法来更改策略，例如，setStrategy方法。</p>
<h3 id="策略模式：何时使用"><a href="#策略模式：何时使用" class="headerlink" title="策略模式：何时使用"></a>策略模式：何时使用</h3><ul>
<li><p>策略模式解决的问题是当你需要使用几种有不同变体的算法时。在那个时候，你需要创建一个具体类来实现你的算法（这可能包含一个或一些函数）。</p>
</li>
<li><p>另一个你发现需要这种模式的有趣时刻是当存在围绕几个相互关联算法的条件语句时。</p>
</li>
<li><p>最后，当你的大多数类具有相关的行为时，你必须使用这种模式。</p>
</li>
</ul>
<h3 id="策略模式：优势"><a href="#策略模式：优势" class="headerlink" title="策略模式：优势"></a>策略模式：优势</h3><p>策略模式具有多个优势，可以总结为以下几点：</p>
<ul>
<li>使用了接口的多态性，因此在运行时轻松切换不同的算法（策略）变得容易。 </li>
<li>代码清晰，因为你避免了条件语句过多的代码（不复杂）。 </li>
<li>代码更加清晰，因为你将关注点分离到不同的类中（每个策略一个类）。</li>
</ul>
<h3 id="策略模式：缺点"><a href="#策略模式：缺点" class="headerlink" title="策略模式：缺点"></a>策略模式：缺点</h3><ul>
<li>如果你的算法极少发生改变， 那么没有任何理由引入新的类和接口。 使用该模式只会让程序过于复杂。</li>
</ul>
<h3 id="策略模式：使用JavaScript的基本实现"><a href="#策略模式：使用JavaScript的基本实现" class="headerlink" title="策略模式：使用JavaScript的基本实现"></a>策略模式：使用JavaScript的基本实现</h3><p>现在，我将向你展示如何使用JavaScript实现这个模式，你需要记住JavaScript没有接口。因此，你需要编写一个名为StrategyManager的类，它被用作接口：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyManager</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_strategy</span> = <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">strategy</span>(<span class="hljs-params">strategy</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_strategy</span> = strategy;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">strategy</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_strategy</span>;<br>  &#125;<br>  <span class="hljs-title function_">doAction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_strategy</span>.<span class="hljs-title function_">doAction</span>();<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这个类包含一个名为_strategy的私有属性，它代表了当前将要使用的策略。doAction方法是将在每个具体策略中实现的方法。由于JavaScript语言缺乏面向对象的特性，策略模式在JavaScript中的实现与UML有所不同。</p>
<p>每个具体策略的实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy1</span> &#123;<br>  <span class="hljs-title function_">doAction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Strategy1&#x27;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy2</span> &#123;<br>  <span class="hljs-title function_">doAction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Strategy2&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>请注意，具体方法doAction在每个具体策略中都得到了实现。</p>
<p>最后，context必须包含StrategyManager（或者在面向对象的语言中是策略接口）以使用具体策略：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> strategyManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrategyManager</span>();<br><span class="hljs-keyword">const</span> strategy1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Strategy1</span>();<br><span class="hljs-keyword">const</span> strategy2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Strategy2</span>();<br><br>strategyManager.<span class="hljs-property">strategy</span> = strategy1; <span class="hljs-comment">//Assign Strategy1;</span><br>strategyManager.<span class="hljs-title function_">doAction</span>();<br><br>strategyManager.<span class="hljs-property">strategy</span> = strategy2; <span class="hljs-comment">// Assign Strategy2;</span><br>strategyManager.<span class="hljs-title function_">doAction</span>();<br></code></pre></td></tr></table></figure>



<h3 id="策略模式：一组策略"><a href="#策略模式：一组策略" class="headerlink" title="策略模式：一组策略"></a>策略模式：一组策略</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyManager</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_strategies</span> = [];<br>  &#125;<br>  <span class="hljs-title function_">addStrategy</span>(<span class="hljs-params">strategy</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_strategies</span> = [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">_strategies</span>, strategy];<br>  &#125;<br>  <span class="hljs-title function_">getStrategy</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_strategies</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">strategy</span> =&gt;</span> strategy.<span class="hljs-property">_name</span> === name);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, handler</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_handler</span> = handler;<br>  &#125;<br>  <span class="hljs-title function_">doAction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_handler</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Client-Context</span><br><span class="hljs-keyword">const</span> strategyManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrategyManager</span>();<br><span class="hljs-keyword">const</span> strategy1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Strategy</span>(<span class="hljs-string">&#x27;strategy1&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Strategy1&#x27;</span>));<br><span class="hljs-keyword">const</span> strategy2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Strategy</span>(<span class="hljs-string">&#x27;strategy2&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Strategy2&#x27;</span>));<br><br>strategyManager.<span class="hljs-title function_">addStrategy</span>(strategy1);<br>strategyManager.<span class="hljs-title function_">addStrategy</span>(strategy2);<br><br><span class="hljs-comment">// Choose first strategy.</span><br><span class="hljs-keyword">const</span> strategyA = strategyManager.<span class="hljs-title function_">getStrategy</span>(<span class="hljs-string">&#x27;strategy1&#x27;</span>);<br>strategyA.<span class="hljs-title function_">doAction</span>();<br><br><span class="hljs-comment">// Choose second strategy.</span><br><span class="hljs-keyword">const</span> strategyB = strategyManager.<span class="hljs-title function_">getStrategy</span>(<span class="hljs-string">&#x27;strategy2&#x27;</span>);<br>strategyB.<span class="hljs-title function_">doAction</span>();<br><br><span class="hljs-comment">// Choose unsupported strategy.</span><br><span class="hljs-keyword">const</span> strategyC = strategyManager.<span class="hljs-title function_">getStrategy</span>(<span class="hljs-string">&#x27;strategy3&#x27;</span>);<br><br><span class="hljs-keyword">try</span> &#123;<br>  strategyC.<span class="hljs-title function_">doAction</span>();<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Caught Error&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>策略模式是一种可以在需要选择具体算法时避免代码复杂性的模式。在这篇文章中，你可以看到使用JavaScript语言的一个简单实现，尽管JavaScript缺乏接口。在你使用具有接口的编程语言的情况下，你可以遵循模式的UML。</p>
<p>最重要的是，不是按照我向你展示的方式实现模式，而是你需要知道模式解决的问题是什么，以及为什么你必须使用它，因为实现将根据编程语言的不同而有所不同。</p>
]]></content>
      <categories>
        <category>Patterns</category>
      </categories>
  </entry>
  <entry>
    <title>answer</title>
    <url>/posts/78a19d7.html</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">retry</span> = <span class="hljs-function">(<span class="hljs-params">fn, times = <span class="hljs-number">0</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> times &gt; <span class="hljs-number">0</span> ? <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">retry</span>(fn, times - <span class="hljs-number">1</span>) : <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>())<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
